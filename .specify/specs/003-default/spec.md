# Feature Specification: Code Context Headers for LLM Understanding

**Feature Branch**: `003-code-context-headers`
**Created**: 2025-12-29
**Status**: Draft
**Input**: User description: "新的任务是更新所有项目文件，添加简要的说明，方便大模型快速读取，获取合适的上下文"

## Clarifications

### Session 2025-12-29

- Q: 头部注释应该使用哪种具体的格式标准？ → A: 使用 # 注释格式（井号）
- Q: 头部注释应包含哪些具体字段，按什么顺序排列？ → A: 三行格式 - 第1行上游依赖、第2行下游用途、第3行模块内作用
- Q: 如何表示"模块"？使用文件路径、模块导入名，还是其他标识符？ → A: 使用简短功能名称（如 Data Models）
- Q: 除了标准三行格式外，是否需要其他可选字段（如文件名、作者、日期等）？ → A: 仅核心三行，保持简洁
- Q: 如何处理 `__init__.py` 文件的头部注释？ → A: 添加完整三行头部，作为模块的代表文件

### Session 2025-12-29 (Addendum)

- Q: 项目结构和模块功能映射表（MODULE_NAME_MAP）应该如何创建和维护？ → A: 使用大模型分析项目结构和每个模块的功能，自动生成映射表
- Q: 大模型分析项目结构的具体流程是什么？ → A: 迭代分析 - 从根目录开始，逐层递归分析每个子目录
- Q: 大模型分析每个模块时，应该读取哪些信息来理解模块功能？ → A: 读取目录下所有文件的完整源代码
- Q: 大模型分析的输出格式应该包含哪些信息？ → A: 完整分析报告，包括所有类、函数、依赖关系的详细说明
- Q: 大模型分析脚本应该在什么时机运行？ → A: 集成到生成脚本中（每次生成头部时自动运行）+ 作为 CI/CD 流程的一部分（每次代码提交时自动更新）

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 核心代码文件上下文头部 (Priority: P1)

作为 AI 大模型或开发者，我需要每个核心代码文件都有标准化的上下文头部，以便快速理解文件的用途和职责。

**场景描述**:
为 Ginkgo 项目中的所有核心 Python 源代码文件（src/ginkgo/ 下的 .py 文件）添加标准化的上下文头部注释。头部应包含：
- 文件名和路径
- 文件用途简述（1-2句话）
- 主要类/函数列表
- 依赖的关键模块
- 所属模块层级（data/trading/client等）

**Why this priority**: 这是核心功能，直接改善 AI 对代码库的理解能力，是最优先实现的部分。

**Independent Test**: 可以独立测试 - 随机选择 10 个核心文件，验证每个文件都有完整的上下文头部，头部内容准确反映文件的实际内容。

**Acceptance Scenarios**:

1. **Given** 一个策略文件（如 base_strategy.py），**When** AI 读取文件，**Then** 能在文件顶部看到完整的用途说明和主要类定义
2. **Given** 一个数据服务文件（如 bar_crud.py），**When** AI 读取文件，**Then** 能看到该文件负责的 CRUD 操作、依赖的数据库模型、支持的主要方法
3. **Given** 任何核心代码文件，**When** AI 读取前 30 行，**Then** 能获得足够的上下文信息理解文件的职责范围

---

### User Story 2 - 测试文件上下文头部 (Priority: P2)

作为 AI 大模型或开发者，我需要测试文件有标准化的上下文头部，以便快速理解测试覆盖范围和测试类型。

**场景描述**:
为所有测试文件（tests/ 下的 .py 文件）添加上下文头部，包含：
- 测试文件名称和路径
- 测试目标（模块/类/功能）
- 测试类型标记（unit/integration/database）
- 主要测试用例类别
- 被测试的源代码模块路径

**Why this priority**: 测试文件是代码质量保证的重要部分，添加上下文头部有助于 AI 理解测试覆盖范围和测试策略。

**Independent Test**: 可以独立测试 - 随机选择 10 个测试文件，验证每个文件都有完整的测试上下文头部。

**Acceptance Scenarios**:

1. **Given** 一个单元测试文件（如 test_bar.py），**When** AI 读取文件，**Then** 能看到测试的是哪个模块、使用了什么 pytest 标记
2. **Given** 一个集成测试文件，**When** AI 读取文件，**Then** 能理解测试涉及哪些模块的集成、测试的数据流是什么样的
3. **Given** 任何测试文件，**When** AI 读取前 20 行，**Then** 能知道测试的类型、覆盖的功能范围

---

### User Story 3 - 配置和文档文件上下文说明 (Priority: P3)

作为 AI 大模型或开发者，我需要配置文件和文档文件有简要说明，以便快速理解文件的作用和配置项。

**场景描述**:
为配置文件（如 pyproject.toml、setup.py）和关键文档（如 README.md）添加上下文说明。对于配置文件，添加注释说明各配置项的用途；对于文档，添加元数据说明文档的目标读者和内容概要。

**Why this priority**: 配置和文档文件数量相对较少，但理解它们有助于全面把握项目结构。

**Independent Test**: 可以独立测试 - 检查所有配置文件，验证关键配置项都有注释说明。

**Acceptance Scenarios**:

1. **Given** pyproject.toml 文件，**When** AI 读取文件，**Then** 能通过注释理解项目依赖、工具配置、脚本命令的用途
2. **Given** .yaml 配置文件，**When** AI 读取文件，**Then** 能看到各配置段的用途说明
3. **Given** README.md，**When** AI 读取文件，**Then** 能在顶部看到项目概述、目标读者、快速开始指引

---

### Edge Cases

- **已有 docstring 的文件**: 如何处理已经有完整 docstring 的文件？避免重复或冲突
- **__init__.py 文件**: MUST 添加完整三行头部，作为模块的代表文件（Upstream 说明哪些模块会导入此模块，Downstream 说明此模块导出/依赖的内容，Role 说明模块的职责）
- **自动生成的文件**: 如从 .proto 生成的 .py 文件，是否需要添加或修改头部？
- **第三方库文件**: vendor/ 或外部依赖的文件不应被修改
- **多语言文件**: 项目中如有非 Python 文件（如 .md、.yaml、.sh），如何处理头部格式？

## Requirements *(mandatory)*

### Functional Requirements

**头部格式标准**:
- **FR-001**: 上下文头部 MUST 使用 # 注释格式（井号），不使用 docstring
- **FR-001.1**: 头部注释 MUST 仅包含标准三行，不添加其他字段（如作者、日期等）：
  - 第1行: `# Upstream: <简短功能名称列表>` - 说明哪些模块会导入/使用本文件（如 "Trading Strategies, Portfolio Manager"）
  - 第2行: `# Downstream: <简短功能名称列表>` - 说明本文件使用哪些模块/主要用途（如 "Data Models, Event System"）
  - 第3行: `# Role: <模块内作用>` - 说明在所属模块中的职责
- **FR-002**: 头部信息通过三行格式体现文件名、用途、主要内容和依赖关系四个核心部分
- **FR-003**: 头部长度 SHOULD 控制在 30 行以内，确保简洁易读
- **FR-004**: 头部内容 MUST 准确反映文件的实际内容，避免误导

**核心代码文件头部要求**:
- **FR-005**: 每个 .py 文件 MUST 在文件顶部添加上下文头部（在 shebang 和编码声明之后）
- **FR-006**: 头部 MUST 说明文件的模块层级（如 "Trading Module - Strategy Layer"）
- **FR-007**: 头部 MUST 列出文件中定义的主要类和函数（最多 10 个，超出的用"等"表示）
- **FR-008**: 头部 MUST 说明依赖的关键外部模块（如 from ginkgo.data import ...）

**测试文件头部要求**:
- **FR-009**: 测试文件头部 MUST 明确测试类型（unit/integration/database）
- **FR-010**: 测试文件头部 MUST 说明被测试的源代码模块路径
- **FR-011**: 测试文件头部 MUST 列出主要的测试用例类别（如 "测试 CRUD 操作"、"测试异常处理"）
- **FR-012**: 测试文件头部 MUST 说明使用的 pytest 标记（@pytest.mark.unit 等）

**配置文件头部要求**:
- **FR-013**: 配置文件的关键配置项 MUST 有行内注释说明用途
- **FR-014**: YAML/JSON 配置文件可在文件开头添加块注释说明整体用途
- **FR-015**: pyproject.toml 的工具依赖和脚本命令 MUST 有注释说明

**质量保证要求**:
- **FR-016**: 添加头部后 MUST 不影响代码的正常执行（纯注释）
- **FR-017**: 头部信息 MUST 保持与代码同步更新（代码重构时更新头部）
- **FR-018**: 头部格式 MUST 在整个项目中保持一致
- **FR-019**: 对于已有 docstring 的类/函数，头部说明 SHOULD 与 docstring 保持一致但不重复

**自动化工具要求**:
- **FR-020**: 系统 SHOULD 提供脚本自动检查文件是否缺少头部
- **FR-021**: 系统 SHOULD 提供脚本自动生成基础头部模板
- **FR-022**: 系统 SHOULD 提供脚本验证头部信息的准确性（如列出的类是否确实存在）

**大模型分析要求**:
- **FR-023**: 系统 MUST 使用大模型分析项目整体结构，生成模块功能映射表
- **FR-024**: 系统 MUST 采用迭代分析方式，从根目录开始逐层递归分析每个子目录
- **FR-025**: 系统 MUST 在生成头部前先让大模型理解每个模块的功能和职责
- **FR-026**: 系统 SHOULD 支持手动审核和修正大模型生成的映射表
- **FR-027**: 大模型分析结果 MUST 缓存到本地文件（如 `.module_mapping.json`），避免重复分析
- **FR-028**: 大模型分析时 MUST 读取目录下所有文件的完整源代码（包括注释和文档字符串）
- **FR-029**: 大模型输出 MUST 包含完整分析报告：模块路径、功能名称、所有类、函数、依赖关系的详细说明
- **FR-030**: 大模型分析 MUST 集成到生成脚本中，每次生成头部时自动运行
- **FR-031**: 系统 SHOULD 提供 CI/CD 集成，每次代码提交时自动更新模块分析结果

### Key Entities

- **File Context Header**: 文件顶部的标准化注释块，包含文件的元信息
- **Module Layer**: 模块层级（如 Data Layer、Trading Layer、Client Layer）
- **Dependency Graph**: 文件依赖关系说明，帮助理解模块间的引用关系
- **Test Coverage Marker**: 测试类型标记（unit/integration/database）

## Success Criteria *(mandatory)*

### Measurable Outcomes

**文件覆盖率指标**:
- **SC-001**: 100% 的核心 Python 源代码文件（src/ginkgo/）都有上下文头部
- **SC-002**: 100% 的测试文件都有测试类型和覆盖范围说明
- **SC-003**: 90% 以上的配置文件关键配置项有注释说明

**质量和准确性指标**:
- **SC-004**: 95% 以上的头部信息准确反映文件实际内容（通过自动验证脚本检查）
- **SC-005**: 90% 以上的新开发者/AI 能通过头部信息正确理解文件用途（通过抽样测试）
- **SC-006**: 头部信息与代码的不一致率 < 5%

**可用性指标**:
- **SC-007**: AI 读取文件的上下文获取时间减少 50%（对比读取全文）
- **SC-008**: 头部信息帮助 AI 准确回答文件相关问题准确率 > 90%
- **SC-009**: 代码审查时理解文件用途的时间减少 40%

**维护性指标**:
- **SC-010**: 提供自动化检查工具，能在 1 分钟内检测缺失的头部
- **SC-011**: 提供自动生成工具，能在 5 秒内为单个文件生成头部模板
- **SC-012**: 头部格式一致性 > 98%（通过 lint 工具检查）

## Assumptions

1. **文件修改安全**: 假设添加纯注释头部不会影响代码执行或引入 bug
2. **AI 解析能力**: 假设 AI 能有效解析标准的注释块和 docstring 格式
3. **维护成本**: 假设头部信息的维护成本可控，通过自动化工具降低负担
4. **现有代码**: 假设大部分现有文件没有完整的上下文说明，需要批量添加
5. **文件数量**: 假设项目中有约 500-1000 个需要添加头部的 Python 文件

## Dependencies

1. **现有代码库**: 需要扫描和分析现有的所有 Python 文件
2. **AST 解析工具**: 使用 Python ast 模块提取类、函数定义
3. **导入分析工具**: 使用 ast 或 importlib 分析模块依赖关系
4. **文件系统操作**: 需要遍历目录、读取和写入文件

## Out of Scope

1. **函数/类级别的 docstring**: 不要求为所有函数和类添加详细 docstring（已有则保留）
2. **注释风格强制**: 不强制要求修改现有的代码注释风格
3. **非代码文件**: 不包括图片、数据文件、编译后的文件
4. **外部依赖**: 不修改 vendor/ 或第三方库的文件
5. **历史注释**: 不删除或修改文件中已有的历史注释说明

## In Scope (明确包含)

1. **Python 源代码文件**: src/ginkgo/ 下所有 .py 文件
2. **测试文件**: tests/ 下所有 .py 文件
3. **配置文件**: pyproject.toml, setup.py, .yaml, .json 等配置文件
4. **关键脚本**: 项目根目录下的 .sh, .py 脚本文件
5. **自动化工具**: 提供检查、生成、验证头部信息的工具脚本
