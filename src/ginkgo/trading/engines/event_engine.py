"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handlers to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""

from typing import TYPE_CHECKING, List, Optional, Dict, Any

if TYPE_CHECKING:
    from ginkgo.trading.portfolios.base_portfolio import BasePortfolio
    from ginkgo.trading.routing import MatchMakingBase
    from ginkgo.trading.events.base_event import EventBase
    from ginkgo.trading.feeders.base_feeder import BaseFeeder as BaseFeed
    from ginkgo.enums import EVENT_TYPES

import uuid
import datetime
import time
import threading
from threading import Thread
from queue import Queue, Empty


from ginkgo.trading.engines.base_engine import BaseEngine
from ginkgo.enums import EXECUTION_MODE
from ginkgo.libs import GCONF
from ginkgo.trading.core.status import EngineStatus, EventStats, QueueInfo


class EventEngine(BaseEngine):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, name: str = "EventEngine", mode: EXECUTION_MODE = EXECUTION_MODE.BACKTEST,
                 timer_interval: float = 1.0, *args, **kwargs) -> None:
        """
        初始化事件引擎（简化API）

        Args:
            name: 引擎名称
            mode: 运行模式
            timer_interval: 定时器间隔（秒）
        """
        # 调用父类构造
        super(EventEngine, self).__init__(name=name, mode=mode, *args, **kwargs)

        # 定时器配置
        self._timer_interval = timer_interval
        self._enable_timer = False  # 定时器开关，默认关闭

        self._main_flag = threading.Event()
        self._main_thread: Thread = Thread(target=self.main_loop, args=(self._main_flag,))
        self._main_thread.daemon = True
        self._main_thread_started = False  # 跟踪主线程是否已启动
        self._timer_flag = threading.Event()
        self._timer_thread: Thread = Thread(target=self.timer_loop, args=(self._timer_flag,))
        self._timer_thread.daemon = True
        self._timer_thread_started = False  # 跟踪定时器线程是否已启动
        self._pause_flag = threading.Event()  # 暂停标志
        self._handlers: dict[EVENT_TYPES, callable] = {}
        self._general_handlers: list = []
        self._timer_handlers: list = []
        # 统一使用父类的 _event_queue，不再使用 _queue
        self._datafeeder = None
        self._matchmaking = None

        # 事件统计（基础功能）
        self._event_stats = {
            'total_events': 0,
            'completed_events': 0,
            'failed_events': 0,
        }
        self._stats_lock = threading.Lock()  # 统计数据的线程安全锁

        # 事件增强功能
        self._sequence_number = 0  # 事件序列号
        self._sequence_lock = threading.Lock()  # 序列号生成的线程安全锁

    @property
    def datafeeder(self):
        return self._datafeeder

    def bind_datafeeder(self, datafeeder: "BaseFeed"):
        """
        绑定数据供给器到引擎

        Args:
            datafeeder: 数据供给器对象，必须实现BaseFeeder接口

        Raises:
            TypeError: 当datafeeder不是有效的BaseFeeder实例时
            AttributeError: 当datafeeder缺少必要方法时
        """
        # 参数验证
        if datafeeder is None:
            raise TypeError("datafeeder cannot be None")

        # 验证datafeeder类型（通过检查必要方法来验证接口兼容性）
        # 由于BaseFeeder在TYPE_CHECKING中，我们通过鸭子类型验证

        # 检查必要方法是否存在
        required_methods = ['bind_engine', 'set_event_publisher']
        for method_name in required_methods:
            if not hasattr(datafeeder, method_name):
                raise AttributeError(f"datafeeder must have method: {method_name}")
            if not callable(getattr(datafeeder, method_name)):
                raise AttributeError(f"datafeeder.{method_name} must be callable")

        # 验证通过后才设置内部状态
        self._datafeeder = datafeeder
        self._datafeeder.bind_engine(self)
        # 明确注入事件发布器，统一回注接口
        self._datafeeder.set_event_publisher(self.put)
        # 去订阅/广播：不再对Feeder注册订阅者，兴趣集合通过事件通告

    @property
    def matchmaking(self) -> "MatchMakingBase":
        return self._matchmaking

    def bind_matchmaking(self, matchmaking: "MatchMakingBase"):
        self._matchmaking = matchmaking
        self._matchmaking.bind_engine(self)
        # 明确注入事件发布器，统一回注接口
        self._matchmaking.set_event_publisher(self.put)

    @property
    def now(self) -> datetime.datetime:
        """获取当前时间 - 子类应重写此方法"""
        return datetime.datetime.now()

    def bind_portfolio(self, portfolio: "BasePortfolio") -> None:
        # ID of this engine is the unique in backtest.
        if portfolio in self.portfolios:
            return
        self.add_portfolio(portfolio)
        self.log("DEBUG", f"{type(self)}:{self.name} bind PORTFOLIO {portfolio.name}.")
        portfolio.bind_engine(self)
        # 明确注入事件发布器，统一回注接口
        portfolio.set_event_publisher(self.put)
        self.log("DEBUG", f"{type(self)}:{self.name} has {len(self.portfolios)} PORTFOLIOs.")
        if self._datafeeder is not None:
            portfolio.bind_data_feeder(self._datafeeder)

    def run(self) -> None:
        """实现BaseEngine的抽象方法"""
        self.start()
        return self
        
    def handle_event(self, event) -> None:
        """实现BaseEngine的抽象方法"""
        self._process(event)

    def main_loop(self, *args, **kwargs) -> None:
        """
        Main event processing loop - 默认实现从事件队列中获取并处理事件
        """
        while not self._main_flag.is_set():
            # 检查暂停标志
            if self._pause_flag.is_set():
                time.sleep(0.1)  # 暂停时短暂休眠
                continue

            # 从事件队列中获取事件
            try:
                event = self._event_queue.get(timeout=1.0)  # 1秒超时
                self._process(event)
            except Empty:
                # 队列为空，继续循环
                continue
            except Exception as e:
                self.log("ERROR", f"Error processing event: {e}")
                continue

        self.log("INFO", "Main loop END.")

    def timer_loop(self, *args, **kwargs) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        while True:
            if self._timer_flag.is_set():
                break
            if self.is_active:  # 使用父类的 is_active 状态
                [handler() for handler in self._timer_handlers]
            time.sleep(self._timer_interval)
        self.log("INFO", "Timer loop END.")

    def enable_timer(self) -> bool:
        """
        启用定时器（仅在timer未启动时有效）

        Returns:
            bool: 操作是否成功
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = True
        self.log("INFO", "Timer enabled.")
        return True

    def disable_timer(self) -> bool:
        """
        禁用定时器（仅在timer未启动时有效）

        Returns:
            bool: 操作是否成功
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = False
        self.log("INFO", "Timer disabled.")
        return True

    def start(self):
        """
        Start the engine
        """
        if not super(EventEngine, self).start():
            return False

        # 清除暂停标志，允许主循环继续运行
        self._pause_flag.clear()

        # 启动已存在的线程对象（每个线程只能启动一次）
        if not self._main_thread_started and not self._main_thread.is_alive():
            self._main_flag.clear()
            self._main_thread.start()
            self._main_thread_started = True

        # 根据开关状态决定是否启动定时器线程
        if self._enable_timer and not self._timer_thread_started and not self._timer_thread.is_alive():
            self._timer_flag.clear()
            self._timer_thread.start()
            self._timer_thread_started = True
            self.log("INFO", f"Timer thread started for engine {self.name}.")

        self.log("INFO", f"Engine {self.name} {self.uuid} STARTED.")
        return True

    def pause(self) -> None:
        """
        Pause the Engine
        """
        if not super(EventEngine, self).pause():
            return False

        # 设置暂停标志，通知主循环进入暂停状态
        self._pause_flag.set()

        self.log("INFO", f"Engine {self.name} {self.uuid} PAUSED.")
        return True

    def stop(self) -> None:
        """
        Stop the Engine
        """
        if not super(EventEngine, self).stop():
            return False

        # 设置停止标志
        self._main_flag.set()
        self._timer_flag.set()

        # 等待线程结束 - 增强线程安全检查，避免join未启动的线程
        if self._main_thread is not None:
            # 只有在线程对象存在且已启动时才尝试join
            if hasattr(self._main_thread, '_started') and self._main_thread._started:
                if self._main_thread.is_alive():
                    self._main_thread.join(timeout=5.0)
            # 即使线程未启动，也重置状态标志
            self._main_thread_started = False

        if self._timer_thread is not None:
            # 只有在线程对象存在且已启动时才尝试join
            if hasattr(self._timer_thread, '_started') and self._timer_thread._started:
                if self._timer_thread.is_alive():
                    self._timer_thread.join(timeout=5.0)
            # 即使线程未启动，也重置状态标志
            self._timer_thread_started = False

        # 重置定时器状态，允许重新操作开关
        self.log("INFO", f"Timer thread stopped for engine {self.name}.")

        # 优雅关闭撮合中心的异步循环（若存在）
        try:
            if self._matchmaking and hasattr(self._matchmaking, "shutdown_async_loop"):
                self._matchmaking.shutdown_async_loop()
        except Exception as e:
            self.log("WARN", f"Failed to shutdown matchmaking: {e}")

        self.log("INFO", f"Engine {self.name} {self.uuid} Stop.")
        self.log("INFO", "Each Portfolio status.")
        for i in self.portfolios:
            self.log("INFO", i)
        return True

    def put(self, event: "EventBase") -> None:
        """
        Put event to queue.
        Args:
            event(Event): Event
        Returns:
            None
        """
        # 统一增强所有事件
        enhanced_event = self._enhance_event(event)

        # 事件计数（基础功能）
        with self._stats_lock:
            self._event_stats['total_events'] += 1

        self._event_queue.put(enhanced_event)
        self.log("DEBUG", f"{type(self)}:{self.name} got an {enhanced_event.event_type} in queue.")

    def _process(self, event: "EventBase") -> None:
        self.log("DEBUG", f"Process {event.event_type}")

        try:
            if event.event_type in self._handlers:
                [handler(event) for handler in self._handlers[event.event_type]]
                self.log("DEBUG", f"{self.name} Deal with {event.event_type}.")
            else:
                self.log("WARN", f"There is no handler for {event.event_type}")

            # General handlers
            [handler(event) for handler in self._general_handlers]

            # 成功计数（基础功能）
            with self._stats_lock:
                self._event_stats['completed_events'] += 1

            # 调用BaseEngine的事件计数机制
            self._increment_event_count()

        except Exception as e:
            # 失败计数（基础功能）
            with self._stats_lock:
                self._event_stats['failed_events'] += 1
            self.log("ERROR", f"Event processing failed: {e}")
            raise

    def register(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Register the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type in self._handlers:
            if handler not in self._handlers[type]:
                self._handlers[type].append(handler)
                return True
            else:
                self.log("WARN", f"handler Exists.")
                return False
        else:
            self._handlers[type] = []
            self._handlers[type].append(handler)
            self.log(
                "INFO", f"Register handler {type} : {handler.__name__}"
            )  # handler.__func__ for method object, not support function object.
            return True

    def unregister(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Unregister the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type not in self._handlers:
            self.log("WARN", f"Event {type} not exists. No need to unregister the handler.")
            return False

        if handler not in self._handlers[type]:
            self.log("WARN", f"Event {type} do not own the handler.")
            return False

        self._handlers[type].remove(handler)
        self.log("DEBUG", f"Unregister handler {type} : {handler}")
        return True

    def register_general(self, handler: callable) -> bool:
        if handler not in self._general_handlers:
            self._general_handlers.append(handler)
            msg = f"RegisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} already exist."
            self.log("WARN", msg)
            return False

    def unregister_general(self, handler: callable) -> bool:
        if handler in self._general_handlers:
            self._general_handlers.remove(handler)
            msg = f"UnregisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} not exist in Generalhandler"
            self.log("WARN", msg)
            return False

    def register_timer(self, handler: callable) -> bool:
        if handler not in self._timer_handlers:
            self._timer_handlers.append(handler)
            self.log("DEBUG", f"Register Timer handler: {handler}")
            return True
        else:
            self.log("WARN", f"Timer handler Exists.")
            return False

    def unregister_timer(self, handler: callable) -> bool:
        if handler in self._timer_handlers:
            self._timer_handlers.remove(handler)
            self.log("DEBUG", f"Unregister Timer handler: {handler}")
            return True
        else:
            msg = f"Timerhandler {handler} not exists."
            self.log("WARN", msg)
            return False

    @property
    def handler_count(self) -> int:
        count = 0
        for i in self._handlers:
            count += len(self._handlers[i])
        return count

    @property
    def general_count(self) -> int:
        return len(self._general_handlers)

    @property
    def timer_count(self) -> int:
        return len(self._timer_handlers)

    @property
    def todo_count(self) -> int:
        return self._event_queue.qsize()

    # === 事件统计接口（基础功能） ===

    @property
    def event_stats(self) -> dict:
        """获取事件统计信息（允许数据不是最新）"""
        return self._event_stats.copy()

    @property
    def total_events(self) -> int:
        """总事件数（允许数据不是最新）"""
        return self._event_stats['total_events']

    @property
    def completed_events(self) -> int:
        """已完成事件数（允许数据不是最新）"""
        return self._event_stats['completed_events']

    @property
    def failed_events(self) -> int:
        """失败事件数（允许数据不是最新）"""
        return self._event_stats['failed_events']

    def reset_event_stats(self) -> None:
        """重置事件统计信息"""
        with self._stats_lock:
            self._event_stats = {
                'total_events': 0,
                'completed_events': 0,
                'failed_events': 0,
            }
        self.log("INFO", "Event statistics reset")

    def _enhance_event(self, event: "EventBase") -> "EventBase":
        """
        增强事件 - 为事件添加运行时上下文信息

        Args:
            event: 原始事件

        Returns:
            EventBase: 增强后的事件
        """
        try:
            # 设置引擎ID和运行ID
            event.engine_id = self.engine_id
            event.run_id = self.run_id or f"{self.engine_id}_init"

            # 设置事件时间戳
            event.set_time(self.now)

            # 分配序列号
            event.sequence_number = self._get_next_sequence_number()

            self.log("DEBUG", f"Event enhanced: {event.event_type} seq={event.sequence_number}")
            return event

        except Exception as e:
            self.log("ERROR", f"Event enhancement failed: {e}")
            # 即使增强失败，也返回原始事件，确保事件流程不中断
            return event

    def _get_next_sequence_number(self) -> int:
        """
        获取下一个事件序列号（线程安全）

        Returns:
            int: 递增的序列号
        """
        with self._sequence_lock:
            self._sequence_number += 1
            return self._sequence_number

    # === 增强的事件查询接口 ===

    def get_registered_handlers_count(self) -> int:
        """
        获取已注册的事件处理器总数（包括专用处理器和通用处理器）

        Returns:
            int: 已注册的处理器总数
        """
        total_count = self.handler_count + self.general_count + self.timer_count
        self.log("DEBUG", f"Registered handlers count: {total_count} (type-specific: {self.handler_count}, general: {self.general_count}, timer: {self.timer_count})")
        return total_count

    def get_handler_distribution(self) -> Dict[str, int]:
        """
        获取处理器分布统计

        Returns:
            Dict[str, int]: 处理器分布统计
                - 'type_specific': 专用类型处理器数量
                - 'general': 通用处理器数量
                - 'timer': 定时器处理器数量
                - 'total': 总处理器数量
        """
        distribution = {
            'type_specific': self.handler_count,
            'general': self.general_count,
            'timer': self.timer_count,
            'total': self.handler_count + self.general_count + self.timer_count
        }
        return distribution

    def get_event_processing_stats(self) -> Dict[str, Any]:
        """
        获取详细的事件处理统计信息

        Returns:
            Dict[str, Any]: 详细的事件处理统计
                - 'total_events': 总事件数
                - 'completed_events': 已完成事件数
                - 'failed_events': 失败事件数
                - 'success_rate': 成功率
                - 'failure_rate': 失败率
                - 'queue_size': 当前队列大小
                - 'handlers_count': 处理器总数
        """
        total = self.total_events
        completed = self.completed_events
        failed = self.failed_events

        # 计算成功率和失败率
        success_rate = (completed / total) if total > 0 else 0.0
        failure_rate = (failed / total) if total > 0 else 0.0

        stats = {
            'total_events': total,
            'completed_events': completed,
            'failed_events': failed,
            'success_rate': success_rate,
            'failure_rate': failure_rate,
            'queue_size': self.todo_count,
            'handlers_count': self.get_registered_handlers_count()
        }

        return stats

    def get_engine_status(self) -> EngineStatus:
        """
        获取引擎基础状态信息（EventEngine扩展）

        Returns:
            EngineStatus: 引擎状态对象
        """
        return EngineStatus(
            is_running=self.is_active,
            current_time=self.now,  # EventEngine提供时间信息
            execution_mode=self._mode,
            processed_events=self._processed_events_count,
            queue_size=self._event_queue.qsize()
        )

    def get_event_stats(self) -> EventStats:
        """
        获取事件处理统计信息（EventEngine增强版）

        Returns:
            EventStats: 增强的事件统计对象，包含处理器注册信息
        """
        current_time = time.time()

        # 计算处理速率
        processing_rate = 0.0
        if self._processing_start_time is not None and self._processed_events_count > 0:
            elapsed_time = current_time - self._processing_start_time
            if elapsed_time > 0:
                processing_rate = self._processed_events_count / elapsed_time

        # 计算已注册的处理器总数
        registered_handlers = self.get_registered_handlers_count()

        return EventStats(
            processed_events=self._processed_events_count,
            registered_handlers=registered_handlers,
            queue_size=self._event_queue.qsize(),
            processing_rate=processing_rate
        )

    def get_queue_info(self) -> QueueInfo:
        """
        获取事件队列信息（EventEngine增强版）

        Returns:
            QueueInfo: 增强的队列信息对象
        """
        queue_size = self._event_queue.qsize()
        max_size = self._event_queue.maxsize if hasattr(self._event_queue, 'maxsize') else 10000

        return QueueInfo(
            queue_size=queue_size,
            max_size=max_size,
            is_full=queue_size >= max_size,
            is_empty=queue_size == 0
        )
