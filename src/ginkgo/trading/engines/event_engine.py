"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handlers to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""

from typing import TYPE_CHECKING, List, Optional, Dict, Any

if TYPE_CHECKING:
    from ginkgo.trading.bases.portfolio_base import PortfolioBase
    from ginkgo.trading.routing import MatchMakingBase
    from ginkgo.trading.events.base_event import EventBase
    from ginkgo.trading.feeders.base_feeder import BaseFeeder as BaseFeed
    from ginkgo.enums import EVENT_TYPES

import uuid
import datetime
import time
import threading
from threading import Thread
from queue import Queue, Empty


from ginkgo.trading.engines.base_engine import BaseEngine
from ginkgo.enums import EXECUTION_MODE
from ginkgo.libs import GCONF
from ginkgo.trading.core.status import EngineStatus, EventStats, QueueInfo


class EventEngine(BaseEngine):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, name: str = "EventEngine", mode: EXECUTION_MODE = EXECUTION_MODE.BACKTEST,
                 timer_interval: float = 1.0, *args, **kwargs) -> None:
        """
        åˆå§‹åŒ–äº‹ä»¶å¼•æ“Žï¼ˆç®€åŒ–APIï¼‰

        Args:
            name: å¼•æ“Žåç§°
            mode: è¿è¡Œæ¨¡å¼
            timer_interval: å®šæ—¶å™¨é—´éš”ï¼ˆç§’ï¼‰
        """
        # è°ƒç”¨çˆ¶ç±»æž„é€ 
        super(EventEngine, self).__init__(name=name, mode=mode, *args, **kwargs)

        # å®šæ—¶å™¨é…ç½®
        self._timer_interval = timer_interval
        self._enable_timer = False  # å®šæ—¶å™¨å¼€å…³ï¼Œé»˜è®¤å…³é—­

        self._main_flag = threading.Event()
        self._main_thread: Thread = Thread(target=self.main_loop, args=(self._main_flag,))
        self._main_thread.daemon = True
        self._main_thread_started = False  # è·Ÿè¸ªä¸»çº¿ç¨‹æ˜¯å¦å·²å¯åŠ¨
        self._timer_flag = threading.Event()
        self._timer_thread: Thread = Thread(target=self.timer_loop, args=(self._timer_flag,))
        self._timer_thread.daemon = True
        self._timer_thread_started = False  # è·Ÿè¸ªå®šæ—¶å™¨çº¿ç¨‹æ˜¯å¦å·²å¯åŠ¨
        self._pause_flag = threading.Event()  # æš‚åœæ ‡å¿—
        self._handlers: dict[EVENT_TYPES, callable] = {}
        self._general_handlers: list = []
        self._timer_handlers: list = []
        # ç»Ÿä¸€ä½¿ç”¨çˆ¶ç±»çš„ _event_queueï¼Œä¸å†ä½¿ç”¨ _queue
        self._datafeeder = None
        self._matchmaking = None

        # äº‹ä»¶ç»Ÿè®¡ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
        self._event_stats = {
            'total_events': 0,
            'completed_events': 0,
            'failed_events': 0,
        }
        self._stats_lock = threading.Lock()  # ç»Ÿè®¡æ•°æ®çš„çº¿ç¨‹å®‰å…¨é”

        # äº‹ä»¶å¢žå¼ºåŠŸèƒ½
        self._sequence_number = 0  # äº‹ä»¶åºåˆ—å·
        self._sequence_lock = threading.Lock()  # åºåˆ—å·ç”Ÿæˆçš„çº¿ç¨‹å®‰å…¨é”

    @property
    def datafeeder(self):
        return self._datafeeder

    def bind_datafeeder(self, datafeeder: "BaseFeed"):
        """
        ç»‘å®šæ•°æ®ä¾›ç»™å™¨åˆ°å¼•æ“Ž

        Args:
            datafeeder: æ•°æ®ä¾›ç»™å™¨å¯¹è±¡ï¼Œå¿…é¡»å®žçŽ°BaseFeederæŽ¥å£

        Raises:
            TypeError: å½“datafeederä¸æ˜¯æœ‰æ•ˆçš„BaseFeederå®žä¾‹æ—¶
            AttributeError: å½“datafeederç¼ºå°‘å¿…è¦æ–¹æ³•æ—¶
        """
        # å‚æ•°éªŒè¯
        if datafeeder is None:
            raise TypeError("datafeeder cannot be None")

        # éªŒè¯datafeederç±»åž‹ï¼ˆé€šè¿‡æ£€æŸ¥å¿…è¦æ–¹æ³•æ¥éªŒè¯æŽ¥å£å…¼å®¹æ€§ï¼‰
        # ç”±äºŽBaseFeederåœ¨TYPE_CHECKINGä¸­ï¼Œæˆ‘ä»¬é€šè¿‡é¸­å­ç±»åž‹éªŒè¯

        # æ£€æŸ¥å¿…è¦æ–¹æ³•æ˜¯å¦å­˜åœ¨
        required_methods = ['bind_engine', 'set_event_publisher']
        for method_name in required_methods:
            if not hasattr(datafeeder, method_name):
                raise AttributeError(f"datafeeder must have method: {method_name}")
            if not callable(getattr(datafeeder, method_name)):
                raise AttributeError(f"datafeeder.{method_name} must be callable")

        # éªŒè¯é€šè¿‡åŽæ‰è®¾ç½®å†…éƒ¨çŠ¶æ€
        self._datafeeder = datafeeder
        self._datafeeder.bind_engine(self)
        # æ˜Žç¡®æ³¨å…¥äº‹ä»¶å‘å¸ƒå™¨ï¼Œç»Ÿä¸€å›žæ³¨æŽ¥å£
        self._datafeeder.set_event_publisher(self.put)
        # åŽ»è®¢é˜…/å¹¿æ’­ï¼šä¸å†å¯¹Feederæ³¨å†Œè®¢é˜…è€…ï¼Œå…´è¶£é›†åˆé€šè¿‡äº‹ä»¶é€šå‘Š

    @property
    def matchmaking(self) -> "MatchMakingBase":
        return self._matchmaking

    def bind_matchmaking(self, matchmaking: "MatchMakingBase"):
        self._matchmaking = matchmaking
        self._matchmaking.bind_engine(self)
        # æ˜Žç¡®æ³¨å…¥äº‹ä»¶å‘å¸ƒå™¨ï¼Œç»Ÿä¸€å›žæ³¨æŽ¥å£
        self._matchmaking.set_event_publisher(self.put)

    @property
    def now(self) -> datetime.datetime:
        """èŽ·å–å½“å‰æ—¶é—´ - å­ç±»åº”é‡å†™æ­¤æ–¹æ³•"""
        return datetime.datetime.now()

    def bind_portfolio(self, portfolio: "PortfolioBase") -> None:
        # ID of this engine is the unique in backtest.
        if portfolio in self.portfolios:
            return
        self.add_portfolio(portfolio)
        self.log("DEBUG", f"{type(self)}:{self.name} bind PORTFOLIO {portfolio.name}.")
        portfolio.bind_engine(self)
        # æ˜Žç¡®æ³¨å…¥äº‹ä»¶å‘å¸ƒå™¨ï¼Œç»Ÿä¸€å›žæ³¨æŽ¥å£
        portfolio.set_event_publisher(self.put)
        self.log("DEBUG", f"{type(self)}:{self.name} has {len(self.portfolios)} PORTFOLIOs.")
        if self._datafeeder is not None:
            portfolio.bind_data_feeder(self._datafeeder)

    def run(self) -> None:
        """å®žçŽ°BaseEngineçš„æŠ½è±¡æ–¹æ³•"""
        self.start()
        return self
        
    def handle_event(self, event) -> None:
        """å®žçŽ°BaseEngineçš„æŠ½è±¡æ–¹æ³•"""
        self._process(event)

    def main_loop(self, *args, **kwargs) -> None:
        """
        Main event processing loop - é»˜è®¤å®žçŽ°ä»Žäº‹ä»¶é˜Ÿåˆ—ä¸­èŽ·å–å¹¶å¤„ç†äº‹ä»¶
        """
        while not self._main_flag.is_set():
            # æ£€æŸ¥æš‚åœæ ‡å¿—
            if self._pause_flag.is_set():
                time.sleep(0.1)  # æš‚åœæ—¶çŸ­æš‚ä¼‘çœ 
                continue

            # ä»Žäº‹ä»¶é˜Ÿåˆ—ä¸­èŽ·å–äº‹ä»¶
            try:
                event = self._event_queue.get(timeout=1.0)  # 1ç§’è¶…æ—¶
                self._process(event)
            except Empty:
                # é˜Ÿåˆ—ä¸ºç©ºï¼Œç»§ç»­å¾ªçŽ¯
                continue
            except Exception as e:
                self.log("ERROR", f"Error processing event: {e}")
                continue

        self.log("INFO", "Main loop END.")

    def timer_loop(self, *args, **kwargs) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        while True:
            if self._timer_flag.is_set():
                break
            if self.is_active:  # ä½¿ç”¨çˆ¶ç±»çš„ is_active çŠ¶æ€
                [handler() for handler in self._timer_handlers]
            time.sleep(self._timer_interval)
        self.log("INFO", "Timer loop END.")

    def enable_timer(self) -> bool:
        """
        å¯ç”¨å®šæ—¶å™¨ï¼ˆä»…åœ¨timeræœªå¯åŠ¨æ—¶æœ‰æ•ˆï¼‰

        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = True
        self.log("INFO", "Timer enabled.")
        return True

    def disable_timer(self) -> bool:
        """
        ç¦ç”¨å®šæ—¶å™¨ï¼ˆä»…åœ¨timeræœªå¯åŠ¨æ—¶æœ‰æ•ˆï¼‰

        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = False
        self.log("INFO", "Timer disabled.")
        return True

    def start(self):
        """
        Start the engine
        """
        if not super(EventEngine, self).start():
            return False

        # æ¸…é™¤æš‚åœæ ‡å¿—ï¼Œå…è®¸ä¸»å¾ªçŽ¯ç»§ç»­è¿è¡Œ
        self._pause_flag.clear()

        # å¯åŠ¨å·²å­˜åœ¨çš„çº¿ç¨‹å¯¹è±¡ï¼ˆæ¯ä¸ªçº¿ç¨‹åªèƒ½å¯åŠ¨ä¸€æ¬¡ï¼‰
        self.log("INFO", f"ðŸ” Before thread start: _main_thread_started={self._main_thread_started}, is_alive={self._main_thread.is_alive()}")
        if not self._main_thread_started and not self._main_thread.is_alive():
            self.log("INFO", f"ðŸ”„ Clearing main_flag before thread start: {not self._main_flag.is_set()}")
            self._main_flag.clear()  # ç¡®ä¿æ¸…é™¤æ ‡å¿—
            self.log("INFO", f"ðŸš€ Starting main thread...")
            self._main_thread.start()
            self._main_thread_started = True
            self.log("INFO", f"âœ… Main thread started, main_flag cleared: {not self._main_flag.is_set()}")

            # ðŸ” æ£€æŸ¥çº¿ç¨‹å¯åŠ¨åŽmain_flagçŠ¶æ€
            import time
            time.sleep(0.01)  # ç»™çº¿ç¨‹ä¸€ç‚¹å¯åŠ¨æ—¶é—´
            self.log("INFO", f"ðŸ” After thread start delay: main_flag.is_set()={self._main_flag.is_set()}")
        else:
            self.log("INFO", f"âš ï¸ Thread not started: _main_thread_started={self._main_thread_started}, is_alive={self._main_thread.is_alive()}")

        # æ ¹æ®å¼€å…³çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨å®šæ—¶å™¨çº¿ç¨‹
        if self._enable_timer and not self._timer_thread_started and not self._timer_thread.is_alive():
            self._timer_flag.clear()
            self._timer_thread.start()
            self._timer_thread_started = True
            self.log("INFO", f"Timer thread started for engine {self.name}.")

        self.log("INFO", f"Engine {self.name} {self.uuid} STARTED.")
        return True

    def pause(self) -> None:
        """
        Pause the Engine
        """
        if not super(EventEngine, self).pause():
            return False

        # è®¾ç½®æš‚åœæ ‡å¿—ï¼Œé€šçŸ¥ä¸»å¾ªçŽ¯è¿›å…¥æš‚åœçŠ¶æ€
        self._pause_flag.set()

        self.log("INFO", f"Engine {self.name} {self.uuid} PAUSED.")
        return True

    def stop(self) -> None:
        """
        Stop the Engine
        """
        import traceback
        self.log("INFO", f"ðŸ”¥ STOP() CALLED! Call stack:")
        for line in traceback.format_stack()[-5:-1]:
            self.log("INFO", f"    {line.strip()}")

        if not super(EventEngine, self).stop():
            return False

        # è®¾ç½®åœæ­¢æ ‡å¿—
        self._main_flag.set()
        self._timer_flag.set()

        # ç­‰å¾…çº¿ç¨‹ç»“æŸ - å¢žå¼ºçº¿ç¨‹å®‰å…¨æ£€æŸ¥ï¼Œé¿å…joinæœªå¯åŠ¨çš„çº¿ç¨‹
        if self._main_thread is not None:
            # åªæœ‰åœ¨çº¿ç¨‹å¯¹è±¡å­˜åœ¨ä¸”å·²å¯åŠ¨æ—¶æ‰å°è¯•join
            if hasattr(self._main_thread, '_started') and self._main_thread._started:
                if self._main_thread.is_alive():
                    self._main_thread.join(timeout=5.0)
            # å³ä½¿çº¿ç¨‹æœªå¯åŠ¨ï¼Œä¹Ÿé‡ç½®çŠ¶æ€æ ‡å¿—
            self._main_thread_started = False

        if self._timer_thread is not None:
            # åªæœ‰åœ¨çº¿ç¨‹å¯¹è±¡å­˜åœ¨ä¸”å·²å¯åŠ¨æ—¶æ‰å°è¯•join
            if hasattr(self._timer_thread, '_started') and self._timer_thread._started:
                if self._timer_thread.is_alive():
                    self._timer_thread.join(timeout=5.0)
            # å³ä½¿çº¿ç¨‹æœªå¯åŠ¨ï¼Œä¹Ÿé‡ç½®çŠ¶æ€æ ‡å¿—
            self._timer_thread_started = False

        # é‡ç½®å®šæ—¶å™¨çŠ¶æ€ï¼Œå…è®¸é‡æ–°æ“ä½œå¼€å…³
        self.log("INFO", f"Timer thread stopped for engine {self.name}.")

        # ä¼˜é›…å…³é—­æ’®åˆä¸­å¿ƒçš„å¼‚æ­¥å¾ªçŽ¯ï¼ˆè‹¥å­˜åœ¨ï¼‰
        try:
            if self._matchmaking and hasattr(self._matchmaking, "shutdown_async_loop"):
                self._matchmaking.shutdown_async_loop()
        except Exception as e:
            self.log("WARN", f"Failed to shutdown matchmaking: {e}")

        self.log("INFO", f"Engine {self.name} {self.uuid} Stop.")
        self.log("INFO", "Each Portfolio status.")
        for i in self.portfolios:
            self.log("INFO", f"Portfolio: {i.name} (ID: {i.uuid})")
        return True

    def put(self, event: "EventBase") -> None:
        """
        Put event to queue.
        Args:
            event(Event): Event
        Returns:
            None
        """
        # ç»Ÿä¸€å¢žå¼ºæ‰€æœ‰äº‹ä»¶
        enhanced_event = self._enhance_event(event)

        # äº‹ä»¶è®¡æ•°ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
        with self._stats_lock:
            self._event_stats['total_events'] += 1

        self._event_queue.put(enhanced_event)
        self.log("DEBUG", f"{type(self)}:{self.name} got an {enhanced_event.event_type} in queue.")

    def _process(self, event: "EventBase") -> None:
        self.log("DEBUG", f"Process {event.event_type}")

        try:
            if event.event_type in self._handlers:
                [handler(event) for handler in self._handlers[event.event_type]]
                self.log("DEBUG", f"{self.name} Deal with {event.event_type}.")
            else:
                self.log("WARN", f"There is no handler for {event.event_type}")

            # General handlers
            [handler(event) for handler in self._general_handlers]

            # æˆåŠŸè®¡æ•°ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
            with self._stats_lock:
                self._event_stats['completed_events'] += 1

            # è°ƒç”¨BaseEngineçš„äº‹ä»¶è®¡æ•°æœºåˆ¶
            self._increment_event_count()

        except Exception as e:
            # å¤±è´¥è®¡æ•°ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
            with self._stats_lock:
                self._event_stats['failed_events'] += 1
            self.log("ERROR", f"Event processing failed: {e}")
            raise

    def register(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Register the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type in self._handlers:
            if handler not in self._handlers[type]:
                self._handlers[type].append(handler)
                return True
            else:
                self.log("WARN", f"handler Exists.")
                return False
        else:
            self._handlers[type] = []
            self._handlers[type].append(handler)
            self.log(
                "INFO", f"Register handler {type} : {handler.__name__}"
            )  # handler.__func__ for method object, not support function object.
            return True

    def unregister(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Unregister the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type not in self._handlers:
            self.log("WARN", f"Event {type} not exists. No need to unregister the handler.")
            return False

        if handler not in self._handlers[type]:
            self.log("WARN", f"Event {type} do not own the handler.")
            return False

        self._handlers[type].remove(handler)
        self.log("DEBUG", f"Unregister handler {type} : {handler}")
        return True

    def register_general(self, handler: callable) -> bool:
        if handler not in self._general_handlers:
            self._general_handlers.append(handler)
            msg = f"RegisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} already exist."
            self.log("WARN", msg)
            return False

    def unregister_general(self, handler: callable) -> bool:
        if handler in self._general_handlers:
            self._general_handlers.remove(handler)
            msg = f"UnregisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} not exist in Generalhandler"
            self.log("WARN", msg)
            return False

    def register_timer(self, handler: callable) -> bool:
        if handler not in self._timer_handlers:
            self._timer_handlers.append(handler)
            self.log("DEBUG", f"Register Timer handler: {handler}")
            return True
        else:
            self.log("WARN", f"Timer handler Exists.")
            return False

    def unregister_timer(self, handler: callable) -> bool:
        if handler in self._timer_handlers:
            self._timer_handlers.remove(handler)
            self.log("DEBUG", f"Unregister Timer handler: {handler}")
            return True
        else:
            msg = f"Timerhandler {handler} not exists."
            self.log("WARN", msg)
            return False

    @property
    def handler_count(self) -> int:
        count = 0
        for i in self._handlers:
            count += len(self._handlers[i])
        return count

    @property
    def general_count(self) -> int:
        return len(self._general_handlers)

    @property
    def timer_count(self) -> int:
        return len(self._timer_handlers)

    @property
    def todo_count(self) -> int:
        return self._event_queue.qsize()

    # === äº‹ä»¶ç»Ÿè®¡æŽ¥å£ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰ ===

    @property
    def event_stats(self) -> dict:
        """èŽ·å–äº‹ä»¶ç»Ÿè®¡ä¿¡æ¯ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats.copy()

    @property
    def total_events(self) -> int:
        """æ€»äº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['total_events']

    @property
    def completed_events(self) -> int:
        """å·²å®Œæˆäº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['completed_events']

    @property
    def failed_events(self) -> int:
        """å¤±è´¥äº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['failed_events']

    def reset_event_stats(self) -> None:
        """é‡ç½®äº‹ä»¶ç»Ÿè®¡ä¿¡æ¯"""
        with self._stats_lock:
            self._event_stats = {
                'total_events': 0,
                'completed_events': 0,
                'failed_events': 0,
            }
        self.log("INFO", "Event statistics reset")

    def _enhance_event(self, event: "EventBase") -> "EventBase":
        """
        å¢žå¼ºäº‹ä»¶ - ä¸ºäº‹ä»¶æ·»åŠ è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ä¿¡æ¯

        Args:
            event: åŽŸå§‹äº‹ä»¶

        Returns:
            EventBase: å¢žå¼ºåŽçš„äº‹ä»¶
        """
        try:
            # è®¾ç½®å¼•æ“ŽIDå’Œè¿è¡ŒID
            event.engine_id = self.engine_id
            event.run_id = self.run_id or f"{self.engine_id}_init"

            # è®¾ç½®äº‹ä»¶æ—¶é—´æˆ³
            event.set_time(self.now)

            # åˆ†é…åºåˆ—å·
            event.sequence_number = self._get_next_sequence_number()

            self.log("DEBUG", f"Event enhanced: {event.event_type} seq={event.sequence_number}")
            return event

        except Exception as e:
            self.log("ERROR", f"Event enhancement failed: {e}")
            # å³ä½¿å¢žå¼ºå¤±è´¥ï¼Œä¹Ÿè¿”å›žåŽŸå§‹äº‹ä»¶ï¼Œç¡®ä¿äº‹ä»¶æµç¨‹ä¸ä¸­æ–­
            return event

    def _get_next_sequence_number(self) -> int:
        """
        èŽ·å–ä¸‹ä¸€ä¸ªäº‹ä»¶åºåˆ—å·ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰

        Returns:
            int: é€’å¢žçš„åºåˆ—å·
        """
        with self._sequence_lock:
            self._sequence_number += 1
            return self._sequence_number

    # === å¢žå¼ºçš„äº‹ä»¶æŸ¥è¯¢æŽ¥å£ ===

    def get_registered_handlers_count(self) -> int:
        """
        èŽ·å–å·²æ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨æ€»æ•°ï¼ˆåŒ…æ‹¬ä¸“ç”¨å¤„ç†å™¨å’Œé€šç”¨å¤„ç†å™¨ï¼‰

        Returns:
            int: å·²æ³¨å†Œçš„å¤„ç†å™¨æ€»æ•°
        """
        total_count = self.handler_count + self.general_count + self.timer_count
        self.log("DEBUG", f"Registered handlers count: {total_count} (type-specific: {self.handler_count}, general: {self.general_count}, timer: {self.timer_count})")
        return total_count

    def get_handler_distribution(self) -> Dict[str, int]:
        """
        èŽ·å–å¤„ç†å™¨åˆ†å¸ƒç»Ÿè®¡

        Returns:
            Dict[str, int]: å¤„ç†å™¨åˆ†å¸ƒç»Ÿè®¡
                - 'type_specific': ä¸“ç”¨ç±»åž‹å¤„ç†å™¨æ•°é‡
                - 'general': é€šç”¨å¤„ç†å™¨æ•°é‡
                - 'timer': å®šæ—¶å™¨å¤„ç†å™¨æ•°é‡
                - 'total': æ€»å¤„ç†å™¨æ•°é‡
        """
        distribution = {
            'type_specific': self.handler_count,
            'general': self.general_count,
            'timer': self.timer_count,
            'total': self.handler_count + self.general_count + self.timer_count
        }
        return distribution

    def get_event_processing_stats(self) -> Dict[str, Any]:
        """
        èŽ·å–è¯¦ç»†çš„äº‹ä»¶å¤„ç†ç»Ÿè®¡ä¿¡æ¯

        Returns:
            Dict[str, Any]: è¯¦ç»†çš„äº‹ä»¶å¤„ç†ç»Ÿè®¡
                - 'total_events': æ€»äº‹ä»¶æ•°
                - 'completed_events': å·²å®Œæˆäº‹ä»¶æ•°
                - 'failed_events': å¤±è´¥äº‹ä»¶æ•°
                - 'success_rate': æˆåŠŸçŽ‡
                - 'failure_rate': å¤±è´¥çŽ‡
                - 'queue_size': å½“å‰é˜Ÿåˆ—å¤§å°
                - 'handlers_count': å¤„ç†å™¨æ€»æ•°
        """
        total = self.total_events
        completed = self.completed_events
        failed = self.failed_events

        # è®¡ç®—æˆåŠŸçŽ‡å’Œå¤±è´¥çŽ‡
        success_rate = (completed / total) if total > 0 else 0.0
        failure_rate = (failed / total) if total > 0 else 0.0

        stats = {
            'total_events': total,
            'completed_events': completed,
            'failed_events': failed,
            'success_rate': success_rate,
            'failure_rate': failure_rate,
            'queue_size': self.todo_count,
            'handlers_count': self.get_registered_handlers_count()
        }

        return stats

    def get_engine_status(self) -> EngineStatus:
        """
        èŽ·å–å¼•æ“ŽåŸºç¡€çŠ¶æ€ä¿¡æ¯ï¼ˆEventEngineæ‰©å±•ï¼‰

        Returns:
            EngineStatus: å¼•æ“ŽçŠ¶æ€å¯¹è±¡
        """
        return EngineStatus(
            is_running=self.is_active,
            current_time=self.now,  # EventEngineæä¾›æ—¶é—´ä¿¡æ¯
            execution_mode=self._mode,
            processed_events=self._processed_events_count,
            queue_size=self._event_queue.qsize()
        )

    def get_event_stats(self) -> EventStats:
        """
        èŽ·å–äº‹ä»¶å¤„ç†ç»Ÿè®¡ä¿¡æ¯ï¼ˆEventEngineå¢žå¼ºç‰ˆï¼‰

        Returns:
            EventStats: å¢žå¼ºçš„äº‹ä»¶ç»Ÿè®¡å¯¹è±¡ï¼ŒåŒ…å«å¤„ç†å™¨æ³¨å†Œä¿¡æ¯
        """
        current_time = time.time()

        # è®¡ç®—å¤„ç†é€ŸçŽ‡
        processing_rate = 0.0
        if self._processing_start_time is not None and self._processed_events_count > 0:
            elapsed_time = current_time - self._processing_start_time
            if elapsed_time > 0:
                processing_rate = self._processed_events_count / elapsed_time

        # è®¡ç®—å·²æ³¨å†Œçš„å¤„ç†å™¨æ€»æ•°
        registered_handlers = self.get_registered_handlers_count()

        return EventStats(
            processed_events=self._processed_events_count,
            registered_handlers=registered_handlers,
            queue_size=self._event_queue.qsize(),
            processing_rate=processing_rate
        )

    def get_queue_info(self) -> QueueInfo:
        """
        èŽ·å–äº‹ä»¶é˜Ÿåˆ—ä¿¡æ¯ï¼ˆEventEngineå¢žå¼ºç‰ˆï¼‰

        Returns:
            QueueInfo: å¢žå¼ºçš„é˜Ÿåˆ—ä¿¡æ¯å¯¹è±¡
        """
        queue_size = self._event_queue.qsize()
        max_size = self._event_queue.maxsize if hasattr(self._event_queue, 'maxsize') else 10000

        return QueueInfo(
            queue_size=queue_size,
            max_size=max_size,
            is_full=queue_size >= max_size,
            is_empty=queue_size == 0
        )
