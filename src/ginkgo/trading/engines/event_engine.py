"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handlers to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""

from typing import TYPE_CHECKING, List, Optional, Dict, Any

if TYPE_CHECKING:
    from ginkgo.trading.bases.portfolio_base import PortfolioBase
    from ginkgo.trading.routing import MatchMakingBase
    from ginkgo.trading.events.base_event import EventBase
    from ginkgo.trading.feeders.base_feeder import BaseFeeder as BaseFeed
    from ginkgo.enums import EVENT_TYPES

import uuid
import datetime
import time
import threading
from threading import Thread
from queue import Queue, Empty


from ginkgo.trading.engines.base_engine import BaseEngine
from ginkgo.enums import EXECUTION_MODE
from ginkgo.libs import GCONF
from ginkgo.trading.core.status import EngineStatus, EventStats, QueueInfo


class EventEngine(BaseEngine):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, name: str = "EventEngine", mode: EXECUTION_MODE = EXECUTION_MODE.BACKTEST,
                 timer_interval: float = 1.0, *args, **kwargs) -> None:
        """
        åˆå§‹åŒ–äº‹ä»¶å¼•æ“ï¼ˆç®€åŒ–APIï¼‰

        Args:
            name: å¼•æ“åç§°
            mode: è¿è¡Œæ¨¡å¼
            timer_interval: å®šæ—¶å™¨é—´éš”ï¼ˆç§’ï¼‰
        """
        # è°ƒç”¨çˆ¶ç±»æ„é€ 
        super(EventEngine, self).__init__(name=name, mode=mode, *args, **kwargs)

        # === åˆå§‹åŒ–äº‹ä»¶å¤„ç†æ ¸å¿ƒç»„ä»¶ ===
        self._init_event_processing()

        # === å®šæ—¶å™¨å’Œçº¿ç¨‹ç®¡ç† ===
        self._timer_interval = timer_interval
        self._enable_timer = False  # å®šæ—¶å™¨å¼€å…³ï¼Œé»˜è®¤å…³é—­
        self._main_flag = threading.Event()
        self._main_thread: Thread = Thread(target=self.main_loop, args=(self._main_flag,))
        self._main_thread.daemon = True
        self._main_thread_started = False
        self._timer_flag = threading.Event()
        self._timer_thread: Thread = Thread(target=self.timer_loop, args=(self._timer_flag,))
        self._timer_thread.daemon = True
        self._timer_thread_started = False
        self._pause_flag = threading.Event()  # æš‚åœæ ‡å¿—

        # === äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ ===
        self._handlers: dict[EVENT_TYPES, list] = {}
        self._general_handlers: list = []
        self._timer_handlers: list = []

        # === å…¶ä»–ç»„ä»¶ ===
        self._datafeeder = None
        self._matchmaking = None

    def _init_event_processing(self):
        """åˆå§‹åŒ–äº‹ä»¶å¤„ç†ç»„ä»¶"""
        # äº‹ä»¶é˜Ÿåˆ—é…ç½®
        self._event_timeout: float = 10.0
        self._event_queue = Queue(maxsize=10000)  # é»˜è®¤é˜Ÿåˆ—å¤§å°
        self._queue_lock = threading.Lock()  # é˜Ÿåˆ—æ“ä½œé”

        # é˜Ÿåˆ—è°ƒæ•´çŠ¶æ€
        self._is_resizing = False
        self._resize_lock = threading.Lock()

        # åºåˆ—å·ç®¡ç†
        self._sequence_number = 0
        self._sequence_lock = threading.Lock()

        # ç»Ÿè®¡ä¿¡æ¯ - é»˜è®¤å¯ç”¨
        self._event_stats = {
            'total_events': 0,
            'completed_events': 0,
            'failed_events': 0,
            'processing_start_time': None
        }
        self._stats_lock = threading.Lock()

    @property
    def datafeeder(self):
        return self._datafeeder

    def bind_datafeeder(self, datafeeder: "BaseFeed"):
        """
        ç»‘å®šæ•°æ®ä¾›ç»™å™¨åˆ°å¼•æ“

        Args:
            datafeeder: æ•°æ®ä¾›ç»™å™¨å¯¹è±¡ï¼Œå¿…é¡»å®ç°BaseFeederæ¥å£

        Raises:
            TypeError: å½“datafeederä¸æ˜¯æœ‰æ•ˆçš„BaseFeederå®ä¾‹æ—¶
            AttributeError: å½“datafeederç¼ºå°‘å¿…è¦æ–¹æ³•æ—¶
        """
        # å‚æ•°éªŒè¯
        if datafeeder is None:
            raise TypeError("datafeeder cannot be None")

        # éªŒè¯datafeederç±»å‹ï¼ˆé€šè¿‡æ£€æŸ¥å¿…è¦æ–¹æ³•æ¥éªŒè¯æ¥å£å…¼å®¹æ€§ï¼‰
        # ç”±äºBaseFeederåœ¨TYPE_CHECKINGä¸­ï¼Œæˆ‘ä»¬é€šè¿‡é¸­å­ç±»å‹éªŒè¯

        # æ£€æŸ¥å¿…è¦æ–¹æ³•æ˜¯å¦å­˜åœ¨
        required_methods = ['bind_engine', 'set_event_publisher']
        for method_name in required_methods:
            if not hasattr(datafeeder, method_name):
                raise AttributeError(f"datafeeder must have method: {method_name}")
            if not callable(getattr(datafeeder, method_name)):
                raise AttributeError(f"datafeeder.{method_name} must be callable")

        # éªŒè¯é€šè¿‡åæ‰è®¾ç½®å†…éƒ¨çŠ¶æ€
        self._datafeeder = datafeeder
        self._datafeeder.bind_engine(self)
        # æ˜ç¡®æ³¨å…¥äº‹ä»¶å‘å¸ƒå™¨ï¼Œç»Ÿä¸€å›æ³¨æ¥å£
        self._datafeeder.set_event_publisher(self.put)
        # å»è®¢é˜…/å¹¿æ’­ï¼šä¸å†å¯¹Feederæ³¨å†Œè®¢é˜…è€…ï¼Œå…´è¶£é›†åˆé€šè¿‡äº‹ä»¶é€šå‘Š

    @property
    def matchmaking(self) -> "MatchMakingBase":
        return self._matchmaking

    def bind_matchmaking(self, matchmaking: "MatchMakingBase"):
        self._matchmaking = matchmaking
        self._matchmaking.bind_engine(self)
        # æ˜ç¡®æ³¨å…¥äº‹ä»¶å‘å¸ƒå™¨ï¼Œç»Ÿä¸€å›æ³¨æ¥å£
        self._matchmaking.set_event_publisher(self.put)

    @property
    def now(self) -> datetime.datetime:
        """è·å–å½“å‰æ—¶é—´ - å­ç±»åº”é‡å†™æ­¤æ–¹æ³•"""
        return datetime.datetime.now()

    def add_portfolio(self, portfolio: "PortfolioBase") -> None:
        """
        æ·»åŠ æŠ•èµ„ç»„åˆåˆ°äº‹ä»¶å¼•æ“

        åœ¨BaseEngineåŸºç¡€åŠŸèƒ½ä¹‹ä¸Šï¼Œæ·»åŠ EventEngineç‰¹æœ‰çš„ç»‘å®šé€»è¾‘ï¼š
        1. è°ƒç”¨çˆ¶ç±»åŸºç¡€ç»‘å®š
        2. è®¾ç½®äº‹ä»¶å‘å¸ƒå™¨
        3. ç»‘å®šæ•°æ®é¦ˆé€å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        """
        # è°ƒç”¨çˆ¶ç±»æ–¹æ³•è¿›è¡ŒåŸºç¡€ç»‘å®š
        super().add_portfolio(portfolio)

        # è®¾ç½®äº‹ä»¶å‘å¸ƒå™¨ - EventEngineç‰¹æœ‰åŠŸèƒ½
        portfolio.set_event_publisher(self.put)

        # ç»‘å®šæ•°æ®é¦ˆé€å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if self._datafeeder is not None:
            portfolio.bind_data_feeder(self._datafeeder)
            self.log("DEBUG", f"Data feeder bound to portfolio {portfolio.name}")

    def run(self) -> None:
        """å®ç°BaseEngineçš„æŠ½è±¡æ–¹æ³•"""
        self.start()
        return self
        
    def handle_event(self, event) -> None:
        """å®ç°BaseEngineçš„æŠ½è±¡æ–¹æ³•"""
        self._process(event)

    def main_loop(self, *args, **kwargs) -> None:
        """
        Main event processing loop - é»˜è®¤å®ç°ä»äº‹ä»¶é˜Ÿåˆ—ä¸­è·å–å¹¶å¤„ç†äº‹ä»¶
        """
        while not self._main_flag.is_set():
            # æ£€æŸ¥æš‚åœæ ‡å¿—
            if self._pause_flag.is_set():
                time.sleep(0.1)  # æš‚åœæ—¶çŸ­æš‚ä¼‘çœ 
                continue

            # ä»äº‹ä»¶é˜Ÿåˆ—ä¸­è·å–äº‹ä»¶
            try:
                event = self._event_queue.get(timeout=1.0)  # 1ç§’è¶…æ—¶
                self._process(event)
            except Empty:
                # é˜Ÿåˆ—ä¸ºç©ºï¼Œç»§ç»­å¾ªç¯
                continue
            except Exception as e:
                self.log("ERROR", f"Error processing event: {e}")
                continue

        self.log("INFO", "Main loop END.")

    def timer_loop(self, *args, **kwargs) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        while True:
            if self._timer_flag.is_set():
                break
            if self.is_active:  # ä½¿ç”¨çˆ¶ç±»çš„ is_active çŠ¶æ€
                [handler() for handler in self._timer_handlers]
            time.sleep(self._timer_interval)
        self.log("INFO", "Timer loop END.")

    def enable_timer(self) -> bool:
        """
        å¯ç”¨å®šæ—¶å™¨ï¼ˆä»…åœ¨timeræœªå¯åŠ¨æ—¶æœ‰æ•ˆï¼‰

        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = True
        self.log("INFO", "Timer enabled.")
        return True

    def disable_timer(self) -> bool:
        """
        ç¦ç”¨å®šæ—¶å™¨ï¼ˆä»…åœ¨timeræœªå¯åŠ¨æ—¶æœ‰æ•ˆï¼‰

        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        if self._timer_thread_started:
            self.log("WARN", "Timer is running, cannot enable/disable.")
            return False

        self._enable_timer = False
        self.log("INFO", "Timer disabled.")
        return True

    def start(self):
        """
        Start the engine
        """
        if not super(EventEngine, self).start():
            return False

        # æ¸…é™¤æš‚åœæ ‡å¿—ï¼Œå…è®¸ä¸»å¾ªç¯ç»§ç»­è¿è¡Œ
        self._pause_flag.clear()

        # å¯åŠ¨å·²å­˜åœ¨çš„çº¿ç¨‹å¯¹è±¡ï¼ˆæ¯ä¸ªçº¿ç¨‹åªèƒ½å¯åŠ¨ä¸€æ¬¡ï¼‰
        self.log("INFO", f"ğŸ” Before thread start: _main_thread_started={self._main_thread_started}, is_alive={self._main_thread.is_alive()}")
        if not self._main_thread_started and not self._main_thread.is_alive():
            self.log("INFO", f"ğŸ”„ Clearing main_flag before thread start: {not self._main_flag.is_set()}")
            self._main_flag.clear()  # ç¡®ä¿æ¸…é™¤æ ‡å¿—
            self.log("INFO", f"ğŸš€ Starting main thread...")
            self._main_thread.start()
            self._main_thread_started = True
            self.log("INFO", f"âœ… Main thread started, main_flag cleared: {not self._main_flag.is_set()}")

            # ğŸ” æ£€æŸ¥çº¿ç¨‹å¯åŠ¨åmain_flagçŠ¶æ€
            import time
            time.sleep(0.01)  # ç»™çº¿ç¨‹ä¸€ç‚¹å¯åŠ¨æ—¶é—´
            self.log("INFO", f"ğŸ” After thread start delay: main_flag.is_set()={self._main_flag.is_set()}")
        else:
            self.log("INFO", f"âš ï¸ Thread not started: _main_thread_started={self._main_thread_started}, is_alive={self._main_thread.is_alive()}")

        # æ ¹æ®å¼€å…³çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨å®šæ—¶å™¨çº¿ç¨‹
        if self._enable_timer and not self._timer_thread_started and not self._timer_thread.is_alive():
            self._timer_flag.clear()
            self._timer_thread.start()
            self._timer_thread_started = True
            self.log("INFO", f"Timer thread started for engine {self.name}.")

        self.log("INFO", f"Engine {self.name} {self.uuid} STARTED.")
        return True

    def pause(self) -> None:
        """
        Pause the Engine
        """
        if not super(EventEngine, self).pause():
            return False

        # è®¾ç½®æš‚åœæ ‡å¿—ï¼Œé€šçŸ¥ä¸»å¾ªç¯è¿›å…¥æš‚åœçŠ¶æ€
        self._pause_flag.set()

        self.log("INFO", f"Engine {self.name} {self.uuid} PAUSED.")
        return True

    def stop(self) -> None:
        """
        Stop the Engine
        """
        import traceback
        self.log("INFO", f"ğŸ”¥ STOP() CALLED! Call stack:")
        for line in traceback.format_stack()[-5:-1]:
            self.log("INFO", f"    {line.strip()}")

        if not super(EventEngine, self).stop():
            return False

        # è®¾ç½®åœæ­¢æ ‡å¿—
        self._main_flag.set()
        self._timer_flag.set()

        # ç­‰å¾…çº¿ç¨‹ç»“æŸ - å¢å¼ºçº¿ç¨‹å®‰å…¨æ£€æŸ¥ï¼Œé¿å…joinæœªå¯åŠ¨çš„çº¿ç¨‹
        if self._main_thread is not None:
            # åªæœ‰åœ¨çº¿ç¨‹å¯¹è±¡å­˜åœ¨ä¸”å·²å¯åŠ¨æ—¶æ‰å°è¯•join
            if hasattr(self._main_thread, '_started') and self._main_thread._started:
                if self._main_thread.is_alive():
                    self._main_thread.join(timeout=5.0)
            # å³ä½¿çº¿ç¨‹æœªå¯åŠ¨ï¼Œä¹Ÿé‡ç½®çŠ¶æ€æ ‡å¿—
            self._main_thread_started = False

        if self._timer_thread is not None:
            # åªæœ‰åœ¨çº¿ç¨‹å¯¹è±¡å­˜åœ¨ä¸”å·²å¯åŠ¨æ—¶æ‰å°è¯•join
            if hasattr(self._timer_thread, '_started') and self._timer_thread._started:
                if self._timer_thread.is_alive():
                    self._timer_thread.join(timeout=5.0)
            # å³ä½¿çº¿ç¨‹æœªå¯åŠ¨ï¼Œä¹Ÿé‡ç½®çŠ¶æ€æ ‡å¿—
            self._timer_thread_started = False

        # é‡ç½®å®šæ—¶å™¨çŠ¶æ€ï¼Œå…è®¸é‡æ–°æ“ä½œå¼€å…³
        self.log("INFO", f"Timer thread stopped for engine {self.name}.")

        # ä¼˜é›…å…³é—­æ’®åˆä¸­å¿ƒçš„å¼‚æ­¥å¾ªç¯ï¼ˆè‹¥å­˜åœ¨ï¼‰
        try:
            if self._matchmaking and hasattr(self._matchmaking, "shutdown_async_loop"):
                self._matchmaking.shutdown_async_loop()
        except Exception as e:
            self.log("WARN", f"Failed to shutdown matchmaking: {e}")

        self.log("INFO", f"Engine {self.name} {self.uuid} Stop.")
        self.log("INFO", "Each Portfolio status.")
        for i in self.portfolios:
            self.log("INFO", f"Portfolio: {i.name} (ID: {i.uuid})")
        return True

    def put(self, event: "EventBase") -> None:
        """
        ç»Ÿä¸€äº‹ä»¶å…¥é˜Ÿæ–¹æ³• - é»˜è®¤å¯ç”¨å¢å¼ºå’Œç»Ÿè®¡

        æ‰€æœ‰äº‹ä»¶éƒ½ä¼šè¢«å¢å¼ºå’Œç»Ÿè®¡ï¼Œç¡®ä¿æ•°æ®å®Œæ•´æ€§å’Œå¯è¿½è¸ªæ€§
        """
        # 1. äº‹ä»¶å¢å¼º - å¼ºåˆ¶æ‰§è¡Œ
        enhanced_event = self._enhance_event(event)

        # 2. ç»Ÿè®¡è®¡æ•° - å¼ºåˆ¶æ‰§è¡Œ
        with self._stats_lock:
            self._event_stats['total_events'] += 1
            if self._event_stats['processing_start_time'] is None:
                self._event_stats['processing_start_time'] = time.time()

        # 3. çº¿ç¨‹å®‰å…¨å…¥é˜Ÿ
        with self._queue_lock:
            self._event_queue.put(enhanced_event)

        self.log("DEBUG", f"Event queued: {enhanced_event.event_type} seq={enhanced_event.sequence_number}")

    def _process(self, event: "EventBase") -> None:
        """å®‰å…¨äº‹ä»¶å¤„ç† - é»˜è®¤å¯ç”¨ç»Ÿè®¡"""
        self.log("DEBUG", f"Process {event.event_type}")

        try:
            # å…·ä½“äº‹ä»¶å¤„ç†å™¨
            if event.event_type in self._handlers:
                [handler(event) for handler in self._handlers[event.event_type]]
                self.log("DEBUG", f"{self.name} Deal with {event.event_type}.")
            else:
                self.log("WARN", f"There is no handler for {event.event_type}")

            # é€šç”¨äº‹ä»¶å¤„ç†å™¨
            [handler(event) for handler in self._general_handlers]

            # ç»Ÿè®¡æˆåŠŸ - å¼ºåˆ¶æ‰§è¡Œ
            with self._stats_lock:
                self._event_stats['completed_events'] += 1

            # è°ƒç”¨çˆ¶ç±»çš„äº‹ä»¶è®¡æ•°æœºåˆ¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if hasattr(super(), '_increment_event_count'):
                super()._increment_event_count()

        except Exception as e:
            # ç»Ÿè®¡å¤±è´¥ - å¼ºåˆ¶æ‰§è¡Œ
            with self._stats_lock:
                self._event_stats['failed_events'] += 1
            self.log("ERROR", f"Event processing failed: {e}")
            raise

    def handle_event(self, event) -> None:
        """ç»Ÿä¸€çš„handle_eventå®ç° - ä½¿ç”¨_processæ–¹æ³•"""
        self._process(event)

    def register(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Register the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type in self._handlers:
            if handler not in self._handlers[type]:
                self._handlers[type].append(handler)
                return True
            else:
                self.log("WARN", f"handler Exists.")
                return False
        else:
            self._handlers[type] = []
            self._handlers[type].append(handler)
            self.log(
                "INFO", f"Register handler {type} : {handler.__name__}"
            )  # handler.__func__ for method object, not support function object.
            return True

    def unregister(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Unregister the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type not in self._handlers:
            self.log("WARN", f"Event {type} not exists. No need to unregister the handler.")
            return False

        if handler not in self._handlers[type]:
            self.log("WARN", f"Event {type} do not own the handler.")
            return False

        self._handlers[type].remove(handler)
        self.log("DEBUG", f"Unregister handler {type} : {handler}")
        return True

    def register_general(self, handler: callable) -> bool:
        if handler not in self._general_handlers:
            self._general_handlers.append(handler)
            msg = f"RegisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} already exist."
            self.log("WARN", msg)
            return False

    def unregister_general(self, handler: callable) -> bool:
        if handler in self._general_handlers:
            self._general_handlers.remove(handler)
            msg = f"UnregisterGeneral : {handler}"
            self.log("DEBUG", msg)
            return True
        else:
            msg = f"{handler} not exist in Generalhandler"
            self.log("WARN", msg)
            return False

    def register_timer(self, handler: callable) -> bool:
        if handler not in self._timer_handlers:
            self._timer_handlers.append(handler)
            self.log("DEBUG", f"Register Timer handler: {handler}")
            return True
        else:
            self.log("WARN", f"Timer handler Exists.")
            return False

    def unregister_timer(self, handler: callable) -> bool:
        if handler in self._timer_handlers:
            self._timer_handlers.remove(handler)
            self.log("DEBUG", f"Unregister Timer handler: {handler}")
            return True
        else:
            msg = f"Timerhandler {handler} not exists."
            self.log("WARN", msg)
            return False

    @property
    def handler_count(self) -> int:
        count = 0
        for i in self._handlers:
            count += len(self._handlers[i])
        return count

    @property
    def general_count(self) -> int:
        return len(self._general_handlers)

    @property
    def timer_count(self) -> int:
        return len(self._timer_handlers)

    @property
    def todo_count(self) -> int:
        return self._event_queue.qsize()

    # === äº‹ä»¶ç»Ÿè®¡æ¥å£ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰ ===

    @property
    def event_stats(self) -> dict:
        """è·å–äº‹ä»¶ç»Ÿè®¡ä¿¡æ¯ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats.copy()

    @property
    def total_events(self) -> int:
        """æ€»äº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['total_events']

    @property
    def completed_events(self) -> int:
        """å·²å®Œæˆäº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['completed_events']

    @property
    def failed_events(self) -> int:
        """å¤±è´¥äº‹ä»¶æ•°ï¼ˆå…è®¸æ•°æ®ä¸æ˜¯æœ€æ–°ï¼‰"""
        return self._event_stats['failed_events']

    def reset_event_stats(self) -> None:
        """é‡ç½®äº‹ä»¶ç»Ÿè®¡ä¿¡æ¯"""
        with self._stats_lock:
            self._event_stats = {
                'total_events': 0,
                'completed_events': 0,
                'failed_events': 0,
            }
        self.log("INFO", "Event statistics reset")

    def _enhance_event(self, event: "EventBase") -> "EventBase":
        """
        å¢å¼ºäº‹ä»¶ - ä¸ºäº‹ä»¶æ·»åŠ è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ä¿¡æ¯

        Args:
            event: åŸå§‹äº‹ä»¶

        Returns:
            EventBase: å¢å¼ºåçš„äº‹ä»¶
        """
        try:
            # è®¾ç½®å¼•æ“IDå’Œè¿è¡ŒID
            event.engine_id = self.engine_id
            event.run_id = self.run_id or f"{self.engine_id}_init"

            # è®¾ç½®äº‹ä»¶æ—¶é—´æˆ³
            event.set_time(self.now)

            # åˆ†é…åºåˆ—å·
            event.sequence_number = self._get_next_sequence_number()

            self.log("DEBUG", f"Event enhanced: {event.event_type} seq={event.sequence_number}")
            return event

        except Exception as e:
            self.log("ERROR", f"Event enhancement failed: {e}")
            # å³ä½¿å¢å¼ºå¤±è´¥ï¼Œä¹Ÿè¿”å›åŸå§‹äº‹ä»¶ï¼Œç¡®ä¿äº‹ä»¶æµç¨‹ä¸ä¸­æ–­
            return event

    def _get_next_sequence_number(self) -> int:
        """
        è·å–ä¸‹ä¸€ä¸ªäº‹ä»¶åºåˆ—å·ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰

        Returns:
            int: é€’å¢çš„åºåˆ—å·
        """
        with self._sequence_lock:
            self._sequence_number += 1
            return self._sequence_number

    # === å¢å¼ºçš„äº‹ä»¶æŸ¥è¯¢æ¥å£ ===

    def get_registered_handlers_count(self) -> int:
        """
        è·å–å·²æ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨æ€»æ•°ï¼ˆåŒ…æ‹¬ä¸“ç”¨å¤„ç†å™¨å’Œé€šç”¨å¤„ç†å™¨ï¼‰

        Returns:
            int: å·²æ³¨å†Œçš„å¤„ç†å™¨æ€»æ•°
        """
        total_count = self.handler_count + self.general_count + self.timer_count
        self.log("DEBUG", f"Registered handlers count: {total_count} (type-specific: {self.handler_count}, general: {self.general_count}, timer: {self.timer_count})")
        return total_count

    def get_handler_distribution(self) -> Dict[str, int]:
        """
        è·å–å¤„ç†å™¨åˆ†å¸ƒç»Ÿè®¡

        Returns:
            Dict[str, int]: å¤„ç†å™¨åˆ†å¸ƒç»Ÿè®¡
                - 'type_specific': ä¸“ç”¨ç±»å‹å¤„ç†å™¨æ•°é‡
                - 'general': é€šç”¨å¤„ç†å™¨æ•°é‡
                - 'timer': å®šæ—¶å™¨å¤„ç†å™¨æ•°é‡
                - 'total': æ€»å¤„ç†å™¨æ•°é‡
        """
        distribution = {
            'type_specific': self.handler_count,
            'general': self.general_count,
            'timer': self.timer_count,
            'total': self.handler_count + self.general_count + self.timer_count
        }
        return distribution

    def get_event_processing_stats(self) -> Dict[str, Any]:
        """
        è·å–è¯¦ç»†çš„äº‹ä»¶å¤„ç†ç»Ÿè®¡ä¿¡æ¯

        Returns:
            Dict[str, Any]: è¯¦ç»†çš„äº‹ä»¶å¤„ç†ç»Ÿè®¡
                - 'total_events': æ€»äº‹ä»¶æ•°
                - 'completed_events': å·²å®Œæˆäº‹ä»¶æ•°
                - 'failed_events': å¤±è´¥äº‹ä»¶æ•°
                - 'success_rate': æˆåŠŸç‡
                - 'failure_rate': å¤±è´¥ç‡
                - 'queue_size': å½“å‰é˜Ÿåˆ—å¤§å°
                - 'handlers_count': å¤„ç†å™¨æ€»æ•°
        """
        total = self.total_events
        completed = self.completed_events
        failed = self.failed_events

        # è®¡ç®—æˆåŠŸç‡å’Œå¤±è´¥ç‡
        success_rate = (completed / total) if total > 0 else 0.0
        failure_rate = (failed / total) if total > 0 else 0.0

        stats = {
            'total_events': total,
            'completed_events': completed,
            'failed_events': failed,
            'success_rate': success_rate,
            'failure_rate': failure_rate,
            'queue_size': self.todo_count,
            'handlers_count': self.get_registered_handlers_count()
        }

        return stats

    def get_engine_status(self) -> EngineStatus:
        """
        è·å–å¼•æ“åŸºç¡€çŠ¶æ€ä¿¡æ¯ï¼ˆEventEngineæ‰©å±•ï¼‰

        Returns:
            EngineStatus: å¼•æ“çŠ¶æ€å¯¹è±¡
        """
        return EngineStatus(
            is_running=self.is_active,
            current_time=self.now,  # EventEngineæä¾›æ—¶é—´ä¿¡æ¯
            execution_mode=self._mode,
            processed_events=self._processed_events_count,
            queue_size=self._event_queue.qsize()
        )

    def get_event_stats(self) -> EventStats:
        """
        è·å–äº‹ä»¶å¤„ç†ç»Ÿè®¡ä¿¡æ¯ï¼ˆEventEngineå¢å¼ºç‰ˆï¼‰

        Returns:
            EventStats: å¢å¼ºçš„äº‹ä»¶ç»Ÿè®¡å¯¹è±¡ï¼ŒåŒ…å«å¤„ç†å™¨æ³¨å†Œä¿¡æ¯
        """
        current_time = time.time()

        # è®¡ç®—å¤„ç†é€Ÿç‡
        processing_rate = 0.0
        if self._processing_start_time is not None and self._processed_events_count > 0:
            elapsed_time = current_time - self._processing_start_time
            if elapsed_time > 0:
                processing_rate = self._processed_events_count / elapsed_time

        # è®¡ç®—å·²æ³¨å†Œçš„å¤„ç†å™¨æ€»æ•°
        registered_handlers = self.get_registered_handlers_count()

        return EventStats(
            processed_events=self._processed_events_count,
            registered_handlers=registered_handlers,
            queue_size=self._event_queue.qsize(),
            processing_rate=processing_rate
        )

    def get_queue_info(self) -> QueueInfo:
        """
        è·å–äº‹ä»¶é˜Ÿåˆ—ä¿¡æ¯ï¼ˆEventEngineå¢å¼ºç‰ˆï¼‰

        Returns:
            QueueInfo: å¢å¼ºçš„é˜Ÿåˆ—ä¿¡æ¯å¯¹è±¡
        """
        queue_size = self._event_queue.qsize()
        max_size = self._event_queue.maxsize if hasattr(self._event_queue, 'maxsize') else 10000

        return QueueInfo(
            queue_size=queue_size,
            max_size=max_size,
            is_full=queue_size >= max_size,
            is_empty=queue_size == 0
        )

    # === é˜Ÿåˆ—ç®¡ç†æ–¹æ³•ï¼ˆä»BaseEngineç§»åŠ¨è¿‡æ¥ï¼‰ ===

    @property
    def event_timeout(self) -> float:
        """äº‹ä»¶è¶…æ—¶æ—¶é—´"""
        return self._event_timeout

    def set_event_timeout(self, timeout: float) -> None:
        """è®¾ç½®äº‹ä»¶è¶…æ—¶æ—¶é—´"""
        self._event_timeout = timeout

    @property
    def is_resizing_queue(self) -> bool:
        """æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦æ­£åœ¨è°ƒæ•´ä¸­"""
        return self._is_resizing

    def set_event_queue_size(self, size: int) -> bool:
        """åŠ¨æ€è°ƒæ•´äº‹ä»¶é˜Ÿåˆ—å¤§å°ï¼ˆåŒç¼“å†²æ–¹æ¡ˆï¼Œä¿è¯äº‹ä»¶ä¸ä¸¢å¤±ï¼‰

        Args:
            size: æ–°çš„é˜Ÿåˆ—å¤§å°

        Returns:
            bool: æ˜¯å¦æˆåŠŸå¯åŠ¨è°ƒæ•´ï¼ˆFalseè¡¨ç¤ºæ­£åœ¨è°ƒæ•´ä¸­ï¼‰
        """
        if size <= 0:
            raise ValueError("Queue size must be positive")

        # æ£€æŸ¥æ˜¯å¦æ­£åœ¨è°ƒæ•´ä¸­
        if self._is_resizing:
            self.log("WARN", f"Queue resize already in progress, cannot resize to {size}")
            return False

        # è·å–è°ƒæ•´é”ï¼Œç¡®ä¿åªæœ‰ä¸€ä¸ªè°ƒæ•´æ“ä½œ
        if not self._resize_lock.acquire(blocking=False):
            self.log("WARN", f"Cannot acquire resize lock, resize in progress")
            return False

        try:
            # è®¾ç½®è°ƒæ•´çŠ¶æ€
            self._is_resizing = True

            old_queue = self._event_queue
            old_size = getattr(old_queue, 'maxsize', 0)

            if old_size == size:
                self.log("INFO", f"Queue size already {size}, no resize needed")
                self._is_resizing = False
                self._resize_lock.release()
                return True

            # åˆ›å»ºä¸´æ—¶é˜Ÿåˆ—æ¥æ”¶æ–°äº‹ä»¶
            temp_queue = Queue(maxsize=size)
            # åˆ›å»ºç›®æ ‡é˜Ÿåˆ—
            new_queue = Queue(maxsize=size)

            with self._queue_lock:
                # åŸå­æ€§åˆ‡æ¢åˆ°ä¸´æ—¶é˜Ÿåˆ—ï¼Œæ–°äº‹ä»¶å°†è¿›å…¥temp_queue
                self._event_queue = temp_queue

            self.log("INFO", f"Queue resize started: {old_size} -> {size}, using temporary buffer")

            # åœ¨åå°è½¬ç§»äº‹ä»¶
            transfer_thread = threading.Thread(
                target=self._transfer_events_with_buffer,
                args=(old_queue, temp_queue, new_queue, old_size, size),
                daemon=True
            )
            transfer_thread.start()
            return True

        except Exception as e:
            # å¼‚å¸¸æ—¶é‡ç½®çŠ¶æ€
            self._is_resizing = False
            self._resize_lock.release()
            self.log("ERROR", f"Queue resize failed: {e}")
            raise

    def _transfer_events_with_buffer(self, old_queue: Queue, temp_queue: Queue,
                                   new_queue: Queue, old_size: int, new_size: int) -> None:
        """ä½¿ç”¨åŒç¼“å†²æ–¹æ¡ˆè½¬ç§»äº‹ä»¶"""
        events_transferred = 0
        events_from_buffer = 0

        try:
            # ç¬¬ä¸€é˜¶æ®µï¼šè½¬ç§»æ—§é˜Ÿåˆ—ä¸­çš„äº‹ä»¶
            self.log("DEBUG", "Phase 1: Transferring events from old queue")
            while not old_queue.empty():
                try:
                    event = old_queue.get_nowait()
                    new_queue.put(event, block=True)  # é˜»å¡ç­‰å¾…ï¼Œä¸ä¸¢å¼ƒ
                    events_transferred += 1
                except Empty:
                    break
                except Exception as e:
                    self.log("ERROR", f"Error transferring old event: {e}")
                    break

            # ç¬¬äºŒé˜¶æ®µï¼šè½¬ç§»ä¸´æ—¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼ˆåœ¨è°ƒæ•´æœŸé—´åˆ°è¾¾çš„æ–°äº‹ä»¶ï¼‰
            self.log("DEBUG", "Phase 2: Transferring events from temporary buffer")
            while True:
                try:
                    # çŸ­æš‚è¶…æ—¶è·å–ä¸´æ—¶é˜Ÿåˆ—äº‹ä»¶ï¼Œé¿å…æ— é™ç­‰å¾…
                    event = temp_queue.get(timeout=0.1)
                    new_queue.put(event, block=True)  # é˜»å¡ç­‰å¾…ï¼Œä¸ä¸¢å¼ƒ
                    events_from_buffer += 1
                except Empty:
                    # ä¸´æ—¶é˜Ÿåˆ—ç©ºäº†ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ–°äº‹ä»¶åˆ°æ¥
                    if temp_queue.empty():
                        break
                    continue
                except Exception as e:
                    self.log("ERROR", f"Error transferring buffered event: {e}")
                    break

            # ç¬¬ä¸‰é˜¶æ®µï¼šåŸå­æ€§æ›¿æ¢åˆ°æ–°é˜Ÿåˆ—
            with self._queue_lock:
                # ç¡®ä¿æ²¡æœ‰å…¶ä»–çº¿ç¨‹å·²ç»æ›¿æ¢äº†é˜Ÿåˆ—
                if self._event_queue is temp_queue:
                    self._event_queue = new_queue

            total_events = events_transferred + events_from_buffer
            self.log("INFO", f"Queue resize completed: {old_size} -> {new_size}, "
                     f"transferred {events_transferred} old events, {events_from_buffer} new events, "
                     f"total {total_events} events")

        except Exception as e:
            self.log("ERROR", f"Queue resize failed: {e}")
            # å‡ºé”™æ—¶æ¢å¤ä½¿ç”¨ä¸´æ—¶é˜Ÿåˆ—
            with self._queue_lock:
                if self._event_queue is temp_queue:
                    self._event_queue = temp_queue

        finally:
            # æ— è®ºå¦‚ä½•éƒ½è¦é‡ç½®è°ƒæ•´çŠ¶æ€å¹¶é‡Šæ”¾é”
            self._is_resizing = False
            self._resize_lock.release()
