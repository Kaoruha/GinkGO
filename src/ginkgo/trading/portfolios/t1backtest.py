"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""

import time
import uuid
from rich.console import Console


from typing import List
from ginkgo.trading.portfolios.base_portfolio import BasePortfolio
from ginkgo.trading.entities.bar import Bar
from ginkgo.trading.entities.position import Position
from ginkgo.trading.entities.signal import Signal
from ginkgo.trading.events import (
    EventOrderAck,
    EventOrderPartiallyFilled,
    EventSignalGeneration,
    EventPriceUpdate,
    EventOrderCancelAck,
)

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, base_repr, to_decimal
from ginkgo.notifier.ginkgo_notifier import GNOTIFIER
from ginkgo.data.models import MOrder
from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
)
from ginkgo.data.containers import container


console = Console()


class PortfolioT1Backtest(BasePortfolio):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        self._signals: List[Signal] = []  # 存储Signal对象，用于T+1延迟执行
        self._orders = []

    @property
    def signals(self):
        return self._signals

    @property
    def orders(self):
        return self._orders

    def get_position(self, code: str) -> Position:
        """
        Get Position object from portfolio.
        Args:
            code(str): code
        Returns:
            return POSITION if it exists else return NONE
        """
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def advance_time(self, time: any, *args, **kwargs) -> None:
        """
        Go next frame.
        Args:
            time(any): new time
        Return:
            None
        """
        # Go next TimePhase - 统一使用hook机制
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        super(PortfolioT1Backtest, self).advance_time(time, *args, **kwargs)
        self.update_worth()
        self.update_profit()

        # 批处理模式：强制处理待处理批次（如果有的话）
        if self._batch_processing_enabled and self._batch_processor:
            try:
                pending_orders = self.force_process_pending_batches()
                if pending_orders:
                    self.log("INFO", f"Processed {len(pending_orders)} pending batch orders at day transition")
            except Exception as e:
                self.log("ERROR", f"Failed to process pending batches during day transition: {e}")

        # Put old SIGNALs to engine (T+1 机制)
        # What a new fucking day
        for signal in self.signals:
            e = EventSignalGeneration(signal)
            self.put(e)

        # Reset past signals
        self._signals = []
        print(self)
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())

    def on_signal(self, event: EventSignalGeneration):
        """
        Dealing with the signal coming.
        支持批处理模式和传统T+1模式
        1. get a signal
        2. after sizer and risk manager
        3.1 drop the signal
        3.2 put order to event engine
        """
        self.log("INFO", f"Got a new Signal about {event.code} {event.direction}. {self.now}")
        self.log(
            "DEBUG", f"{self.name} got a {event.direction} signal about {event.code}  --> {event.direction}. {self.now}"
        )
        
        # Check Feature Message.
        if self.is_event_from_future(event):
            return
        # Check Everything.
        if not self.is_all_set():
            return
            
        # 批处理模式处理
        if self._batch_processing_enabled and self._batch_processor:
            try:
                # T+1机制：当天信号延迟到明天处理
                if event.timestamp == self.now:
                    self.log(
                        "DEBUG",
                        f"T+1 Batch Mode: Signal {event.code} will be processed in next day's batch. {self.now}",
                    )
                    self.signals.append(event.value)
                    return
                
                # 使用批处理感知的信号处理
                self._batch_aware_on_signal(event)
                return
                
            except Exception as e:
                self.log("ERROR", f"Batch signal processing failed, falling back to traditional mode: {e}")
                # 继续执行传统处理逻辑
        
        # 传统T+1处理逻辑
        # T+1, Order will send after 1 day that signal comes.
        if event.timestamp == self.now:
            self.log(
                "DEBUG",
                f"T+1 Portfolio should not send the order generated from the signal today {event.timestamp}, we will send the order tomorrow. {self.now}",
            )
            self.signals.append(event.value)
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(self.get_info(), event.value)
        # 2. Get the order return
        if order is None:
            self.log("INFO", f"No ORDER about {event.code} generated by sizer. {self.now}")
            return
        self.log("INFO", f"Generate an ORDER about {order.code} {order.direction} by sizer. {self.now}")

        # 3. Transfer the order to risk_managers
        for risk_manager in self.risk_managers:
            order = risk_manager.cal(self.get_info(), order)
            if order is None:
                break

        # 4. Get the adjusted order, if so put eventorder to engine
        if order is None:
            self.log("WARN", f"ORDER about {event.code} prevent by risk manager. {self.now}")
            return
        # Prevent Doing Zero Volume Order
        if order.volume == 0:
            self.log("WARN", f"ORDER about {event.code} prevent by zero volume. {self.now}")
            return
        order.frozen = round(order.frozen, 2)
        order.remain = round(order.remain, 2)
        if order.direction == DIRECTION_TYPES.LONG:
            freeze_ok = self.freeze(order.frozen)
            if not freeze_ok:
                self.log("INFO", f"Can not afford the ORDER about {event.code}. {self.now}")
                return
        elif order.direction == DIRECTION_TYPES.SHORT:
            if order.code not in self.positions.keys():
                self.log("INFO", f"Do not have position about {order.code}. {self.now}")
                return
            freeze_ok = self.get_position(order.code).freeze(order.volume)
            if not freeze_ok:
                self.log("INFO", f"Do not have enough position about {order.code}. {self.now}")
                return
        event = EventOrderAck(order, broker_order_id=f"BROKER_{order.uuid[:8]}")
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        self.put(event)

    def on_price_received(self, event: EventPriceUpdate):
        # Check Everything.
        code = ""
        try:
            code = event.code
        except Exception as e:
            pass
        self.log("INFO", f"Got new price {code if code != '' else ""}. {self.now}")
        if not self.is_all_set():
            return

        # 0 Time check
        if self.is_event_from_future(event):
            return

        # 1. Update position price
        if event.code in self.positions:
            self.positions[event.code].on_price_update(event.close)
            self.update_worth()
            self.update_profit()

        # 2. Transfer price to each strategy
        if len(self.strategies) == 0:
            self.log("CRITICAL", f"There is no strategy in the portfolio. Check your config. {self.now}")
            return

        # GLOG.INFO(f"Under {len(self.strategies)} Strategies Calculating... {self.now}")
        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signals = []
            try:
                signals = strategy.cal(self.get_info(), event)

                # 防御性处理：确保signals是列表类型
                if signals is None:
                    signals = []
                elif not isinstance(signals, list):
                    # 如果返回的是单个Signal对象，包装成列表
                    if hasattr(signals, "code"):  # 简单检查是否是Signal对象
                        signals = [signals]
                        self.log(
                            "WARN",
                            f"Strategy {strategy.name} returned single Signal instead of List[Signal], auto-wrapped",
                        )
                    else:
                        self.log("ERROR", f"Strategy {strategy.name} returned invalid type {type(signals)}, ignoring")
                        signals = []

            except Exception as e:
                self.log("ERROR", f"Strategy {strategy.name} cal() failed: {e}")
                signals = []
            finally:
                pass
            # 处理每个信号
            for signal in signals:
                if signal:
                    # 将信号保存到数据库
                    try:
                        signal_crud = container.cruds.signal()
                        signal_crud.create(
                            portfolio_id=signal.portfolio_id,
                            engine_id=signal.engine_id,
                            timestamp=signal.timestamp,
                            code=signal.code,
                            direction=signal.direction,
                            reason=signal.reason,
                            source=signal.source,
                        )
                        self.log("DEBUG", f"Signal saved to database: {signal.code} {signal.direction}")
                    except Exception as e:
                        self.log("ERROR", f"Failed to save signal to database: {e}")

                    e = EventSignalGeneration(signal)
                    e.set_source(SOURCE_TYPES.STRATEGY)
                    for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    self.put(e)

    def on_order_partially_filled(self, event: EventOrderPartiallyFilled):
        self.log("INFO", f"Got An Order Filled... {self.now}")
        # debug breakpoint removed
        if self.is_event_from_future(event):
            return

        if not event.order_status == ORDERSTATUS_TYPES.FILLED:
            self.log(
                "CRITICAL",
                f"On Order Filled only handle the FILLEDORDER, cant handle a {event.order_status} one. Check the Code. {self.now}",
            )
            return
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"DEALING with LONG FILLED ORDER. {self.now}")
            self.deal_long_filled(event)
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"DEALING with SHORT FILLED ORDER. {self.now}")
            self.deal_short_filled(event)
        self.log("INFO", f"Got An Order Filled Done. {self.now}")
        self.update_worth()
        self.update_profit()

    def on_order_cancel_ack(self, event: EventOrderCancelAck):
        self.log("INFO", f"Got An Order Cancelled... {self.now}")
        # debug breakpoint removed
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        self.log("WARN", f"Dealing with CANCELED ORDER. {self.now}")
        if self.is_event_from_future(event):
            return
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"START UNFREEZE LONG. {self.now}")
            self.unfreeze(event.frozen)
            self.add_cash(event.frozen)
            self.log("INFO", f"Dealing ORDER about {event.code} CANCELED. add frozen cash {event.frozen} {self.now}")
            self.log("WARN", f"DONE UNFREEZE LONG. {self.now}")
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"START UNFREEZE SHOTR. {self.now}")
            code = event.code
            pos = self.positions[code]
            pos.unfreeze(event.volume)
            self.log("WARN", f"DONE UNFREEZE SHORT. {self.now}")
        self.update_worth()
        self.update_profit()

    # ===== 新增：订单生命周期事件处理（ACK/部分成交/拒绝/过期/撤销确认） =====
    def on_order_ack(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            self.log("INFO", f"ACK: order={event.order_id[:8]} code={event.code} msg={getattr(event, 'ack_message', '')}")
            # 可选：跟踪订单
            if hasattr(self, "_orders") and event.order not in self._orders:
                self._orders.append(event.order)
        except Exception as e:
            self.log("ERROR", f"on_order_ack failed: {e}")

    def on_order_partially_filled(self, event) -> None:
        try:
            if self.is_event_from_future(event):
                return
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())

            qty = int(getattr(event, "filled_quantity", 0) or 0)
            price = to_decimal(getattr(event, "fill_price", 0) or 0)
            fee = to_decimal(getattr(event, "commission", 0) or 0)
            if qty <= 0 or price <= 0:
                self.log("WARN", f"Partial fill ignored due to invalid qty/price: {qty}/{price}")
                return

            direction = event.order.direction if hasattr(event, "order") else None
            code = event.code

            # LONG 部分成交：消耗冻结资金（成交额+手续费），增加/建立持仓
            if direction == DIRECTION_TYPES.LONG:
                cost_used = price * qty + fee
                self.unfreeze(cost_used)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    p = Position(
                        portfolio_id=self.uuid,
                        code=code,
                        cost=price,
                        volume=qty,
                        price=price,
                        frozen=0,
                        fee=fee,
                        uuid=uuid.uuid4().hex,
                    )
                    self.add_position(p)
                else:
                    pos.deal(DIRECTION_TYPES.LONG, price, qty)

                self.log("INFO", f"PARTIAL LONG filled {code}: {qty}@{price}, fee={fee}")

            # SHORT 部分成交：入账现金（成交额-手续费），消耗持仓冻结量
            elif direction == DIRECTION_TYPES.SHORT:
                proceeds = price * qty - fee
                self.add_cash(proceeds)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    self.log("ERROR", f"Partial SHORT fill but no position found for {code}")
                else:
                    pos.deal(DIRECTION_TYPES.SHORT, price, qty)
                    self.clean_positions()

                self.log("INFO", f"PARTIAL SHORT filled {code}: {qty}@{price}, fee={fee}")
            else:
                self.log("WARN", f"Partial fill with unknown direction for {code}")

            # 更新组合指标
            self.update_worth()
            self.update_profit()

        except Exception as e:
            self.log("ERROR", f"on_order_partially_filled failed: {e}")

    def on_order_rejected(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            self.log("WARN", f"REJECTED: order={event.order_id[:8]} code={event.code} reason={event.reject_reason}")
            # BrokerMatchMaking 会同时发送取消事件以触发资金解冻；此处仅记录
        except Exception as e:
            self.log("ERROR", f"on_order_rejected failed: {e}")

    def on_order_expired(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            self.log("WARN", f"EXPIRED: order={event.order_id[:8]} code={event.code} reason={event.expire_reason}")
            # 过期一般伴随取消事件；组合在取消事件中做资金/仓位回滚
        except Exception as e:
            self.log("ERROR", f"on_order_expired failed: {e}")

    def on_order_cancel_ack(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())
            self.log(
                "INFO",
                f"CANCEL-ACK: order={event.order_id[:8]} code={event.code} cancelled_qty={event.cancelled_quantity}"
            )
        except Exception as e:
            self.log("ERROR", f"on_order_cancel_ack failed: {e}")

    def deal_long_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        if self.frozen < event.frozen:
            self.log("CRITICAL", f"Over flow, can not unfreeze {event.frozen} from {self.frozen}. {self.now}")
            return
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        self.unfreeze(event.frozen)
        self.add_cash(event.remain)
        self.add_fee(event.fee)
        p = Position(
            portfolio_id=self.uuid,
            code=event.code,
            cost=event.transaction_price,
            volume=event.transaction_volume,
            price=event.transaction_price,
            frozen=0,
            fee=event.fee,
            uuid=uuid.uuid4().hex,
        )
        self.add_position(p)
        self.log("WARN", f"Fill a LONG ORDER DONE. {self.now}")

    def deal_short_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        if event.code not in self.positions.keys():
            self.log("CRITICAL", f"Can not handler the short order about no exist {event.code}. {self.now}")
            return
        if event.transaction_volume > self.positions[event.code].frozen_volume:
            self.log("CRITICAL", f"Can not handler the short order about over flow. {self.now}")
            return
        self.add_cash(event.remain)
        self.log("INFO", f"Got an short filled order, add remain cash: {event.remain}. {self.now}")
        self.add_fee(event.fee)
        self.positions[event.code].deal(DIRECTION_TYPES.SHORT, event.transaction_price, event.transaction_volume)
        self.clean_positions()
        self.log("WARN", f"Fill a SHORT ORDER DONE. {self.now}")

    def __repr__(self) -> str:
        return base_repr(self, PortfolioT1Backtest.__name__, 24, 70)
