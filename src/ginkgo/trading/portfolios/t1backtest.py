"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""

import time
import uuid
import datetime
from rich.console import Console


from typing import List
from decimal import Decimal
from ginkgo.trading.bases.portfolio_base import PortfolioBase
from ginkgo.trading.entities.bar import Bar
from ginkgo.trading.entities.position import Position
from ginkgo.trading.entities.signal import Signal
from ginkgo.trading.events import (
    EventOrderAck,
    EventOrderPartiallyFilled,
    EventSignalGeneration,
    EventPriceUpdate,
    EventOrderCancelAck,
)

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, base_repr, to_decimal
from ginkgo.interfaces.notification_interface import INotificationService, NotificationServiceFactory
from ginkgo.data.models import MOrder
from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
)
from ginkgo.data.containers import container


console = Console()


class PortfolioT1Backtest(PortfolioBase):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, notification_service: INotificationService = None, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        # ä½¿ç”¨ä¾èµ–æ³¨å…¥çš„é€šçŸ¥æœåŠ¡ï¼Œå¦‚æœæ²¡æœ‰æä¾›åˆ™è‡ªåŠ¨åˆ›å»º
        self._notification_service = notification_service or NotificationServiceFactory.create_service()
        self._signals: List[Signal] = []  # å­˜å‚¨Signalå¯¹è±¡ï¼Œç”¨äºT+1å»¶è¿Ÿæ‰§è¡Œ
        self._orders = []

    @property
    def signals(self):
        return self._signals

    @property
    def orders(self):
        return self._orders

    def get_position(self, code: str) -> Position:
        """
        Get Position object from portfolio.
        Args:
            code(str): code
        Returns:
            return POSITION if it exists else return NONE
        """
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def advance_time(self, time: any, *args, **kwargs) -> None:
        """
        æ—¶é—´æ¨è¿›åˆ°ä¸‹ä¸€å‘¨æœŸ
        åŒ…å«å®Œæ•´çš„T+1äº¤æ˜“åˆ¶åº¦å®ç°ï¼š
        1. å¤„ç†T+1ç»“ç®—é˜Ÿåˆ—ï¼ˆæŒä»“è§£å†»ï¼‰
        2. æ‰¹é‡å¤„ç†å»¶è¿Ÿä¿¡å·
        3. æ›´æ–°æŠ•èµ„ç»„åˆçŠ¶æ€
        """
        from ginkgo.libs import datetime_normalize

        new_time = datetime_normalize(time)

        # ===== æ­¥éª¤1: T+1ç»“ç®—å¤„ç† =====
        # å¤„ç†æ‰€æœ‰æŒä»“çš„ç»“ç®—é˜Ÿåˆ—ï¼Œå°†åˆ°æœŸçš„å†»ç»“æŒä»“è½¬ä¸ºå¯ç”¨
        settled_positions = 0
        for code, position in self.positions.items():
            initial_settlement_frozen = position.settlement_frozen_volume
            if initial_settlement_frozen > 0:
                position.process_settlement_queue(new_time)
                if position.settlement_frozen_volume < initial_settlement_frozen:
                    settled_positions += 1
                    self.log(
                        "INFO",
                        f"Position {code}: {initial_settlement_frozen - position.settlement_frozen_volume} shares settled, "
                        f"available: {position.volume}, settlement_frozen: {position.settlement_frozen_volume}",
                    )

        if settled_positions > 0:
            self.log("INFO", f"Processed settlement for {settled_positions} positions")

        # ===== æ­¥éª¤2: æ—¶é—´æ¨è¿›å’ŒçŠ¶æ€æ›´æ–° =====
        # Go next TimePhase - ç»Ÿä¸€ä½¿ç”¨hookæœºåˆ¶
        self.update_worth()
        self.update_profit()

        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())

        super(PortfolioT1Backtest, self).advance_time(time, *args, **kwargs)

        # ===== æ­¥éª¤3: æ‰¹å¤„ç†æ¨¡å¼å¤„ç† =====
        if self._batch_processing_enabled and self._batch_processor:
            try:
                pending_orders = self.force_process_pending_batches()
                if pending_orders:
                    self.log("INFO", f"Processed {len(pending_orders)} pending batch orders at day transition")
            except Exception as e:
                self.log("ERROR", f"Failed to process pending batches during day transition: {e}")

        # ===== æ­¥éª¤4: T+1ä¿¡å·æ‰¹é‡å¤„ç† =====
        # æ¨è¿›åˆ°æ–°æ—¶é—´åï¼Œæ‰¹é‡å¤„ç†ä¸ŠæœŸçš„å»¶è¿Ÿä¿¡å·
        delayed_signals_count = len(self._signals)
        # å–æ¶ˆè¯¦ç»†çš„PortfolioçŠ¶æ€æ‰“å°ä»¥é¿å…æ€§èƒ½å¼€é”€
        # print(f"ğŸ•°ï¸ [TIME ADVANCE] Portfolio time advance to {time}: {self}")
        self.log("INFO", f"ğŸ•°ï¸ Portfolio time advance to {time}, {delayed_signals_count} delayed signals")

        if delayed_signals_count > 0:
            self.log(
                "WARNING",
                f"âš¡ [T+1 PROCESSING] Processing {delayed_signals_count} delayed T+1 signals from previous period",
            )
            for i, signal in enumerate(self._signals):
                self.log(
                    "WARNING",
                    f"ğŸ”„ [T+1 REPUBLISH #{i+1}] Re-publishing delayed signal: {signal.direction.name} for {signal.code}, timestamp={signal.business_timestamp}",
                )
                e = EventSignalGeneration(signal)
                self.log("WARNING", f"ğŸ“¤ [T+1 PUT] Putting EventSignalGeneration to event engine")
                self.put(e)
                self.log("WARNING", f"âœ… [T+1 REPUBLISH #{i+1}] Successfully republished")
        else:
            self.log("WARNING", "â­• [T+1 EMPTY] No delayed T+1 signals to process")

        # Reset past signals
        old_count = len(self._signals)
        self._signals = []
        self.log("WARNING", f"ğŸ§¹ [T+1 CLEANUP] Cleared {old_count} delayed signals from queue")

        # ===== æ­¥éª¤5: æ–°æ—¶é—´çŠ¶æ€åˆå§‹åŒ– =====
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())

    def on_signal(self, event: EventSignalGeneration):
        """
        Dealing with the signal coming.
        æ”¯æŒæ‰¹å¤„ç†æ¨¡å¼å’Œä¼ ç»ŸT+1æ¨¡å¼
        1. get a signal
        2. after sizer and risk manager
        3.1 drop the signal
        3.2 put order to event engine
        """

        def normalize_time_for_comparison(t):
            """æ ‡å‡†åŒ–æ—¶é—´ç”¨äºæ¯”è¾ƒï¼Œè§£å†³æ—¶åŒºä¸åŒ¹é…é—®é¢˜"""
            if t is None:
                return None
            # å¦‚æœæœ‰æ—¶é—´ä¿¡æ¯ï¼Œè½¬æ¢ä¸ºUTCæ—¶é—´å¹¶å»é™¤æ—¶åŒºä¿¡æ¯ï¼Œä¿æŒdatetimeå¯¹è±¡ç±»å‹
            if hasattr(t, "tzinfo") and t.tzinfo is not None:
                utc_tuple = t.utctimetuple()
                # æ ‡å‡†åŒ–å¤ä»¤æ—¶å­—æ®µä¸º0ï¼Œç¡®ä¿ä¸€è‡´æ€§
                return utc_tuple[:8] + (0,)  # tm_isdst=0
            # å·²ç»æ˜¯naiveæ—¶é—´ï¼Œè½¬æ¢ä¸ºstruct_timeä»¥ä¿æŒä¸€è‡´æ€§
            if isinstance(t, datetime.datetime):
                naive_tuple = t.timetuple()
                # æ ‡å‡†åŒ–å¤ä»¤æ—¶å­—æ®µä¸º0ï¼Œç¡®ä¿ä¸€è‡´æ€§
                return naive_tuple[:8] + (0,)  # tm_isdst=0
            # å¦‚æœå·²ç»æ˜¯å…¶ä»–æ—¶é—´è¡¨ç¤ºï¼Œç›´æ¥è¿”å›
            return t

        current_time = self.get_time_provider().now()
        self.log("INFO", f"Got a new Signal about {event.code} {event.direction}. {current_time}")
        # æ£€æŸ¥æ˜¯å¦æ˜¯æœªæ¥æ—¶é—´ï¼Œå¦‚æœæ˜¯åˆ™ä½¿ç”¨CRITICALç­‰çº§
        if event.business_timestamp and current_time and event.business_timestamp > current_time:
            self.log(
                "CRITICAL",
                f"ğŸš¨ [FUTURE TIME] on_signal called with FUTURE event.business_timestamp={event.business_timestamp}, current_time={current_time} ***",
            )
        else:
            self.log(
                "INFO",
                f"*** on_signal called with event.business_timestamp={event.business_timestamp}, current_time={current_time} ***",
            )

        # Check Feature Message.
        future_check = self.is_event_from_future(event)
        self.log("INFO", f"*** is_event_from_future returned: {future_check} ***")
        if future_check:
            self.log(
                "CRITICAL",
                f"ğŸš¨ [FUTURE TIME] Event from future, dropping signal: event.business_timestamp={event.business_timestamp} > current_time={current_time} ***",
            )
            return
        # Check Everything.
        all_set_check = self.is_all_set()
        self.log("INFO", f"*** is_all_set returned: {all_set_check} ***")
        if not all_set_check:
            self.log("INFO", f"*** Portfolio not fully set, dropping signal ***")
            return
        else:
            self.log("INFO", f"*** Portfolio all_set OK, proceeding with signal processing ***")

        # æ‰¹å¤„ç†æ¨¡å¼å¤„ç†
        self.log("INFO", f"=== BATCH PROCESSING CHECK ===")
        self.log("INFO", f"batch_processing_enabled: {self._batch_processing_enabled}")
        self.log("INFO", f"batch_processor exists: {self._batch_processor is not None}")
        self.log("INFO", f"==============================")

        if self._batch_processing_enabled and self._batch_processor:
            try:
                # T+1æœºåˆ¶ï¼šå½“å¤©ä¿¡å·å»¶è¿Ÿåˆ°æ˜å¤©å¤„ç†
                # æ³¨æ„ï¼šæ‰¹å¤„ç†æ¨¡å¼ä¹Ÿéœ€è¦å¤„ç†æ—¶åŒºé—®é¢˜
                business_time_normalized = normalize_time_for_comparison(event.business_timestamp)
                current_time_normalized = normalize_time_for_comparison(current_time)

                # T+1å»¶è¿Ÿæœºåˆ¶ï¼šå¦‚æœä¿¡å·æ—¶é—´ >= å½“å‰æ—¶é—´ï¼Œåˆ™å»¶è¿Ÿåˆ°ä¸‹ä¸€ä¸ªæ—¶é—´ç‚¹å¤„ç†
                self.log(
                    "INFO",
                    f"T+1 Decision: business_time={business_time_normalized} >= current_time={current_time_normalized} ? {business_time_normalized >= current_time_normalized}",
                )
                if business_time_normalized >= current_time_normalized:
                    if business_time_normalized > current_time_normalized:
                        self.log(
                            "CRITICAL",
                            f"ğŸš¨ [FUTURE TIME] Batch Mode: Future signal from {event.business_timestamp} (current: {current_time}), delaying to next period.",
                        )
                    else:
                        self.log(
                            "INFO",
                            f"T+1 Batch Mode: delaying current day signal {event.code} to next period. {current_time}",
                        )
                    self._signals.append(event.payload)
                    self.log("INFO", f"Signal added to _signals queue. Total signals: {len(self._signals)}")
                    return

                # ä½¿ç”¨æ‰¹å¤„ç†æ„ŸçŸ¥çš„ä¿¡å·å¤„ç†
                self._batch_aware_on_signal(event)
                return

            except Exception as e:
                self.log("ERROR", f"Batch signal processing failed, falling back to traditional mode: {e}")
                # ç»§ç»­æ‰§è¡Œä¼ ç»Ÿå¤„ç†é€»è¾‘

        # ä¼ ç»ŸT+1å¤„ç†é€»è¾‘
        # T+1, Order will send after 1 day that signal comes.
        # æ³¨æ„ï¼šæ—¶é—´æ¯”è¾ƒéœ€è¦å¤„ç†æ—¶åŒºé—®é¢˜ï¼Œå°†ä¸¤ä¸ªæ—¶é—´éƒ½è½¬æ¢ä¸ºUTCæˆ–naiveæ—¶é—´
        business_time_normalized = normalize_time_for_comparison(event.business_timestamp)
        current_time_normalized = normalize_time_for_comparison(current_time)

        self.log("INFO", f"=== T+1 TIME COMPARISON DEBUG ===")
        self.log("INFO", f"event.business_timestamp: {event.business_timestamp}")
        self.log("INFO", f"current_time from time_provider: {current_time}")
        self.log("INFO", f"normalized business_time: {business_time_normalized}")
        self.log("INFO", f"normalized current_time: {current_time_normalized}")
        self.log("INFO", f"Are they equal after normalization? {business_time_normalized == current_time_normalized}")
        self.log("INFO", f"=====================================")
        self.log(
            "INFO", f"T+1 CHECK: business_time >= current_time? {business_time_normalized >= current_time_normalized}"
        )

        # T+1å»¶è¿Ÿæœºåˆ¶ï¼šå¦‚æœä¿¡å·æ—¶é—´ >= å½“å‰æ—¶é—´ï¼Œåˆ™å»¶è¿Ÿåˆ°ä¸‹ä¸€ä¸ªæ—¶é—´ç‚¹å¤„ç†
        # è¿™ç¡®ä¿åªæœ‰è¿‡å»çš„ä¿¡å·æ‰ä¼šè¢«ç«‹å³å¤„ç†ï¼Œå½“å¤©å’Œæœªæ¥çš„ä¿¡å·éƒ½ä¼šè¢«å»¶è¿Ÿ
        if business_time_normalized >= current_time_normalized:
            self.log("WARNING", f"ğŸš¦ [T+1 DECISION] DELAYING signal (business_time >= current_time)")
            if business_time_normalized > current_time_normalized:
                self.log(
                    "CRITICAL",
                    f"ğŸš¨ [FUTURE TIME] Individual Mode: Future signal from {event.business_timestamp} (current: {current_time}), delaying to next period.",
                )
            else:
                self.log(
                    "WARNING",
                    f"â° [T+1 DELAY] Delaying current day signal from {event.business_timestamp} (current: {current_time}), will process in next period.",
                )
            self._signals.append(event.payload)
            self.log("WARNING", f"ğŸ“¥ [T+1 QUEUE] Signal added to _signals queue. Total signals: {len(self._signals)}")
            return

        # 1. Transfer signal to sizer
        self.log("WARNING", f"ğŸ¯ [SIGNAL TO ORDER] Calling sizer.cal() for signal {event.code} {event.direction}")
        portfolio_info = self.get_info()
        self.log(
            "WARNING",
            f"ğŸ¯ [PORTFOLIO INFO] cash={portfolio_info.get('cash', 'N/A')}, positions={len(portfolio_info.get('positions', {}))}",
        )

        self.log("WARNING", f"ğŸ”§ [SIZER CALL] About to call sizer.cal()...")
        try:
            order = self.sizer.cal(portfolio_info, event.payload)
            self.log(
                "WARNING",
                f"ğŸ“‹ [SIZER RESULT] sizer.cal() returned: {type(order).__name__ if order else 'None'} - {order}",
            )
        except Exception as e:
            self.log("ERROR", f"âŒ [SIZER EXCEPTION] sizer.cal() failed with exception: {type(e).__name__}: {e}")
            import traceback

            self.log("ERROR", f"ğŸ“‹ [SIZER TRACEBACK] {traceback.format_exc()}")
            order = None

        # 2. Get the order return
        if order is None:
            self.log(
                "ERROR",
                f"âŒ [SIZER FAILED] No ORDER about {event.code} generated by sizer. Signal: {event.direction}, Portfolio cash: {self.get_info().get('cash', 'N/A')}",
            )
            return
        else:
            self.log(
                "WARNING",
                f"âœ… [ORDER GENERATED] {order.direction.name} {order.volume} shares of {order.code} @ {order.limit_price or 'MARKET'} (uuid: {order.uuid[:8]})",
            )
        self.log(
            "WARNING",
            f"ğŸ“‹ [ORDER INFO] Generated ORDER about {order.code} {order.direction} by sizer. {self.business_timestamp}",
        )

        # 3. Transfer the order to risk_managers
        self.log("WARNING", f"ğŸ›¡ï¸ [RISK MANAGEMENT] Processing order through {len(self.risk_managers)} risk managers")
        for i, risk_manager in enumerate(self.risk_managers):
            order_before_rm = order
            order = risk_manager.cal(self.get_info(), order)
            if order is None:
                self.log(
                    "WARNING",
                    f"âš ï¸ ORDER BLOCKED by risk manager #{i+1} ({risk_manager.__class__.__name__}) for {event.code}",
                )
                return
            else:
                if order_before_rm.volume != order.volume:
                    self.log(
                        "INFO", f"ğŸ“Š RISK MANAGER #{i+1} adjusted volume: {order_before_rm.volume} â†’ {order.volume}"
                    )

        # 4. Get the adjusted order, if so put eventorder to engine
        if order is None:
            self.log("WARN", f"ORDER about {event.code} prevent by risk manager. {self.business_timestamp}")
            return
        # Prevent Doing Zero Volume Order
        if order.volume == 0:
            self.log("WARN", f"ORDER about {event.code} prevent by zero volume. {self.business_timestamp}")
            return
        order.frozen_money = round(order.frozen_money, 2)
        order.remain = round(order.remain, 2)
        # è‹¥æœªæ˜¾å¼è®¾ç½®remainï¼Œåˆ™ä»¥å†»ç»“é‡‘é¢ä¸ºå‡†ï¼Œä¾¿äºéƒ¨åˆ†æˆäº¤æŒ‰å‰©ä½™å†»ç»“å¤„ç†
        if order.remain is None or to_decimal(order.remain) == 0:
            order.remain = to_decimal(order.frozen_money)

        # 5. Cash/Position freezing
        if order.direction == DIRECTION_TYPES.LONG:
            # ===== LONG SIGNAL PROCESSING START =====
            self.log("INFO", f"ğŸ”¥ [LONG SIGNAL] === START PROCESSING {event.code} ===")
            self.log(
                "INFO",
                f"ğŸ”¥ [LONG SIGNAL] Portfolio BEFORE: cash={self.cash:.2f}, frozen={self.frozen:.2f}, total_available={self.cash + self.frozen:.2f}",
            )
            self.log(
                "INFO",
                f"ğŸ”¥ [LONG SIGNAL] Order details: volume={order.volume}, frozen_money={order.frozen_money:.2f}, limit_price={order.limit_price}, uuid={order.uuid[:8]}",
            )
            self.log("INFO", f"ğŸ’° CASH FREEZE: Attempting to freeze {order.frozen_money} for LONG order {event.code}")
            self.log("INFO", f"ğŸ’° Current cash before freeze: {self.cash}")
            freeze_ok = self.freeze(order.frozen_money)
            if not freeze_ok:
                self.log(
                    "WARNING",
                    f"âŒ INSUFFICIENT CASH: Cannot afford ORDER about {event.code}. Need: {order.frozen_money}, Have: {self.cash}",
                )
                self.log("ERROR", f"ğŸ”¥ [LONG SIGNAL] === FAILED PROCESSING {event.code} (INSUFFICIENT CASH) ===")
                return
            self.log("INFO", f"âœ… CASH FROZEN: {order.frozen_money}, Remaining cash: {self.cash}")
            self.log("INFO", f"ğŸ”¥ [LONG SIGNAL] Portfolio AFTER FREEZE: cash={self.cash:.2f}, frozen={self.frozen:.2f}")
            self.log("INFO", f"ğŸ”¥ [LONG SIGNAL] === SUCCESSFULLY FROZEN {event.code} ===")
            # ===== LONG SIGNAL PROCESSING END =====
        elif order.direction == DIRECTION_TYPES.SHORT:
            self.log(
                "INFO", f"ğŸ“‰ POSITION FREEZE: Attempting to freeze {order.volume} shares for SHORT order {event.code}"
            )
            if order.code not in self.positions.keys():
                self.log(
                    "WARNING", f"âŒ NO POSITION: Do not have position about {order.code}. {self.business_timestamp}"
                )
                return
            current_pos_volume = self.get_position(order.code).volume
            self.log("INFO", f"ğŸ“‰ Current position: {current_pos_volume} shares, Need to freeze: {order.volume}")
            freeze_ok = self.get_position(order.code).freeze(order.volume)
            if not freeze_ok:
                self.log(
                    "WARNING",
                    f"âŒ INSUFFICIENT POSITION: Do not have enough position about {order.code}. Need: {order.volume}, Have: {current_pos_volume}",
                )
                return
            self.log("INFO", f"âœ… POSITION FROZEN: {order.volume} shares of {event.code}")
        # 6. Create and submit order event to engine
        self.log(
            "INFO",
            f"ğŸ“¤ ORDER SUBMISSION: Creating EventOrderAck for {order.direction.name} {order.volume} shares of {order.code}",
        )
        # è°ƒè¯•ï¼šæ£€æŸ¥å¼•æ“ç»‘å®šçŠ¶æ€
        self.log(
            "INFO",
            f"ğŸ” [EVENT DEBUG] Creating EventOrderAck - portfolio_id={self.uuid}, engine_id={self.engine_id}, run_id={self.run_id}",
        )
        self.log(
            "INFO",
            f"ğŸ” [EVENT DEBUG] Bound engine: {self.bound_engine}, Engine ID: {self.bound_engine.engine_id if self.bound_engine else None}",
        )

        event = EventOrderAck(order, portfolio_id=self.uuid, engine_id=self.engine_id, run_id=self.run_id)
        event.broker_order_id = f"BROKER_{order.uuid[:8]}"

        # Set the order as payload for unified access
        event.payload = order

        # Call analyzer hooks
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())

        # Submit to engine
        self.log(
            "WARNING",
            f"ğŸš€ [ORDER TO ENGINE] Submitting order event to engine for matchmaking - Event: {event.uuid[:8] if hasattr(event, 'uuid') else 'N/A'}",
        )
        self.log(
            "WARNING",
            f"ğŸ“‹ [EVENT DETAILS] Event type: {type(event).__name__}, Order: {event.order.code if hasattr(event, 'order') else 'N/A'}",
        )
        self.put(event)
        self.log("WARNING", f"âœ… [ORDER FLOW COMPLETE] Signal â†’ Order â†’ Risk Management â†’ Freezing â†’ Engine submission")

    def on_price_received(self, event: EventPriceUpdate):
        # Check Everything.
        code = ""
        try:
            code = event.code
        except Exception as e:
            pass
        self.log("INFO", f"Got new price {code if code != '' else ""}. {self.business_timestamp}")
        if not self.is_all_set():
            return

        # 0 Time check
        if self.is_event_from_future(event):
            return

        # 1. Update position price
        if event.code in self.positions:
            self.positions[event.code].on_price_update(event.close)
            self.update_worth()
            self.update_profit()

        # 2. Transfer price to each strategy
        if len(self.strategies) == 0:
            self.log("CRITICAL", f"There is no strategy in the portfolio. Check your config. {self.business_timestamp}")
            return

        # GLOG.INFO(f"Under {len(self.strategies)} Strategies Calculating... {self.business_timestamp}")
        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signals = []
            try:
                signals = strategy.cal(self.get_info(), event)

                # é˜²å¾¡æ€§å¤„ç†ï¼šç¡®ä¿signalsæ˜¯åˆ—è¡¨ç±»å‹
                if signals is None:
                    signals = []
                elif not isinstance(signals, list):
                    # å¦‚æœè¿”å›çš„æ˜¯å•ä¸ªSignalå¯¹è±¡ï¼ŒåŒ…è£…æˆåˆ—è¡¨
                    if hasattr(signals, "code"):  # ç®€å•æ£€æŸ¥æ˜¯å¦æ˜¯Signalå¯¹è±¡
                        signals = [signals]
                        self.log(
                            "WARN",
                            f"Strategy {strategy.name} returned single Signal instead of List[Signal], auto-wrapped",
                        )
                    else:
                        self.log("ERROR", f"Strategy {strategy.name} returned invalid type {type(signals)}, ignoring")
                        signals = []

            except Exception as e:
                self.log("ERROR", f"Strategy {strategy.name} cal() failed: {e}")
                signals = []
            finally:
                pass
            # å¤„ç†æ¯ä¸ªä¿¡å·
            for signal in signals:
                if signal:
                    # å°†ä¿¡å·ä¿å­˜åˆ°æ•°æ®åº“
                    try:
                        signal_crud = container.cruds.signal()
                        signal_crud.create(
                            portfolio_id=signal.portfolio_id,
                            engine_id=signal.engine_id,
                            timestamp=signal.timestamp,
                            code=signal.code,
                            direction=signal.direction,
                            reason=signal.reason,
                            source=signal.source,
                            business_timestamp=signal.business_timestamp,  # æ·»åŠ ä¸šåŠ¡æ—¶é—´æˆ³
                        )
                        self.log("DEBUG", f"Signal saved to database: {signal.code} {signal.direction}")
                    except Exception as e:
                        self.log("ERROR", f"Failed to save signal to database: {e}")

                    e = EventSignalGeneration(signal)
                    e.set_source(SOURCE_TYPES.STRATEGY)
                    for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    self.put(e)

    # ===== æ–°å¢ï¼šè®¢å•ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¤„ç†ï¼ˆACK/éƒ¨åˆ†æˆäº¤/æ‹’ç»/è¿‡æœŸ/æ’¤é”€ç¡®è®¤ï¼‰ =====
    def on_order_ack(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            self.log(
                "INFO", f"ACK: order={event.order_id[:8]} code={event.code} msg={getattr(event, 'ack_message', '')}"
            )
            # å¯é€‰ï¼šè·Ÿè¸ªè®¢å•
            if hasattr(self, "_orders") and event.order not in self._orders:
                self._orders.append(event.order)
        except Exception as e:
            self.log("ERROR", f"on_order_ack failed: {e}")

    def on_order_partially_filled(self, event) -> None:
        try:
            if self.is_event_from_future(event):
                return
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())

            order = getattr(event, "order", None)
            if order is None:
                self.log("ERROR", "Partial fill event missing order payload")
                return

            qty = int(getattr(event, "filled_quantity", 0) or 0)
            price = to_decimal(getattr(event, "fill_price", 0) or 0)
            fee = to_decimal(getattr(event, "commission", 0) or 0)
            if qty <= 0 or price <= 0:
                self.log("WARN", f"Partial fill ignored due to invalid qty/price: {qty}/{price}")
                return

            direction = getattr(order, "direction", None) or getattr(event, "direction", None)
            code = event.code
            fill_cost = price * qty + fee

            # æ›´æ–°è®¢å•ç´¯è®¡æˆäº¤ä¸å‰©ä½™å†»ç»“
            try:
                order.transaction_volume = min(order.volume, order.transaction_volume + qty)
            except Exception as e:
                self.log("ERROR", f"Failed to update transaction_volume: {e}")

            if not hasattr(order, "remain") or order.remain is None:
                order.remain = order.frozen_money
            order.remain = to_decimal(order.remain)
            order.remain = max(Decimal("0"), order.remain - fill_cost)

            is_final = (
                getattr(event, "order_status", None) == ORDERSTATUS_TYPES.FILLED
                or order.transaction_volume >= order.volume
            )

            # LONG éƒ¨åˆ†æˆäº¤ï¼šåªæ‰£é™¤å·²æˆäº¤æˆæœ¬ï¼Œä¿ç•™å‰©ä½™å†»ç»“ï¼›æœ«æ¬¡æˆäº¤æˆ–æ ‡è®°FILLEDæ—¶é‡Šæ”¾å·®é¢
            if direction == DIRECTION_TYPES.LONG:
                unfreeze_remain = order.remain if is_final else None
                self.deduct_from_frozen(cost=fill_cost, unfreeze_remain=unfreeze_remain)
                if is_final:
                    order.remain = Decimal("0")
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    p = Position(
                        portfolio_id=self.uuid,
                        engine_id=self.engine_id,
                        run_id=self.run_id,
                        code=code,
                        cost=price,
                        volume=qty,
                        price=price,
                        frozen=0,
                        fee=fee,
                        uuid=uuid.uuid4().hex,
                    )
                    self.add_position(p)
                else:
                    pos.deal(DIRECTION_TYPES.LONG, price, qty)

                self.log(
                    "INFO",
                    f"PARTIAL LONG filled {code}: {qty}@{price}, fee={fee}, remain_frozen={order.remain}",
                )

            # SHORT éƒ¨åˆ†æˆäº¤ï¼šå…¥è´¦ç°é‡‘ï¼ˆæˆäº¤é¢-æ‰‹ç»­è´¹ï¼‰ï¼Œå·²å†»ç»“ä»“ä½éšæˆäº¤é€’å‡ï¼Œå‰©ä½™å†»ç»“ä¿æŒ
            elif direction == DIRECTION_TYPES.SHORT:
                proceeds = price * qty - fee
                self.add_cash(proceeds)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    self.log("ERROR", f"Partial SHORT fill but no position found for {code}")
                else:
                    pos.deal(DIRECTION_TYPES.SHORT, price, qty)
                    self.clean_positions()

                self.log("INFO", f"PARTIAL SHORT filled {code}: {qty}@{price}, fee={fee}")
            else:
                self.log("WARN", f"Partial fill with unknown direction for {code}")

            # æ›´æ–°ç»„åˆæŒ‡æ ‡
            self.update_worth()
            self.update_profit()

        except Exception as e:
            self.log("ERROR", f"on_order_partially_filled failed: {e}")

    def on_order_rejected(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            self.log("WARN", f"REJECTED: order={event.order_id[:8]} code={event.code} reason={event.reject_reason}")
            # BrokerMatchMaking ä¼šåŒæ—¶å‘é€å–æ¶ˆäº‹ä»¶ä»¥è§¦å‘èµ„é‡‘è§£å†»ï¼›æ­¤å¤„ä»…è®°å½•
        except Exception as e:
            self.log("ERROR", f"on_order_rejected failed: {e}")

    def on_order_expired(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            self.log("WARN", f"EXPIRED: order={event.order_id[:8]} code={event.code} reason={event.expire_reason}")
            # è¿‡æœŸä¸€èˆ¬ä¼´éšå–æ¶ˆäº‹ä»¶ï¼›ç»„åˆåœ¨å–æ¶ˆäº‹ä»¶ä¸­åšèµ„é‡‘/ä»“ä½å›æ»š
        except Exception as e:
            self.log("ERROR", f"on_order_expired failed: {e}")

    def on_order_cancel_ack(self, event) -> None:
        try:
            self.log("INFO", f"Got An Order Cancelled... {self.business_timestamp}")
            # å¤„ç†ORDERCANCELEDé˜¶æ®µçš„hooks
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
                func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
                func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())

            # å¤„ç†ORDERCANCELACKé˜¶æ®µçš„hooks
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())

            self.log("WARN", f"Dealing with CANCELED ORDER. {self.business_timestamp}")
            if self.is_event_from_future(event):
                return

            order = getattr(event, "order", None)
            direction = getattr(event, "direction", None) or (order.direction if hasattr(order, "direction") else None)

            if direction == DIRECTION_TYPES.LONG:
                remain = None
                if order is not None:
                    remain = getattr(order, "remain", None)
                    if remain is None:
                        remain = getattr(order, "frozen_money", 0)
                if remain is None:
                    self.log("ERROR", f"Cancel event missing remain for {event.code}")
                    return
                remain = to_decimal(remain)
                if remain > 0:
                    self.unfreeze(remain)
                    if order is not None:
                        order.remain = Decimal("0")
                self.log(
                    "INFO",
                    f"Dealing ORDER about {event.code} CANCELED. unfrozen cash {remain} {self.business_timestamp}",
                )
            elif direction == DIRECTION_TYPES.SHORT:
                code = event.code
                pos = self.positions.get(code)
                cancel_vol = int(getattr(event, "cancelled_quantity", 0) or 0)
                if pos is None:
                    self.log("ERROR", f"Cancel SHORT but position missing for {code}")
                else:
                    if cancel_vol > 0:
                        pos.unfreeze(cancel_vol)
                self.log("WARN", f"DONE UNFREEZE SHORT. {self.business_timestamp}")

            self.log(
                "INFO",
                f"CANCEL-ACK: order={getattr(event, 'order_id', 'N/A')[:8]} code={event.code} cancelled_qty={getattr(event, 'cancelled_quantity', 'N/A')}",
            )
            self.update_worth()
            self.update_profit()

        except Exception as e:
            self.log("ERROR", f"on_order_cancel_ack failed: {e}")

    def on_order_filled(self, event) -> None:
        """è®¢å•å®Œå…¨æˆäº¤äº‹ä»¶å¤„ç†å™¨ - ç‰¹æ®Šçš„partially_filled (remain=0)"""
        try:
            # è§¦å‘åˆ†æå™¨è®°å½•
            for func in self._analyzer_activate_hook.get(RECORDSTAGE_TYPES.ORDERFILLED, []):
                func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
            for func in self._analyzer_record_hook.get(RECORDSTAGE_TYPES.ORDERFILLED, []):
                func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())

            self.log("INFO", f"Portfolio {self.name}: Order completely filled")

            # å§”æ‰˜ç»™ç°æœ‰çš„éƒ¨åˆ†æˆäº¤å¤„ç†å™¨ï¼Œå¤ç”¨æ‰€æœ‰ç°æœ‰é€»è¾‘
            # ORDERFILLEDæœ¬è´¨ä¸Šæ˜¯remain=0çš„ç‰¹æ®ŠORDERPARTIALLYFILLED
            self.on_order_partially_filled(event)
        except Exception as e:
            self.log("ERROR", f"on_order_filled failed: {e}")

    def deal_long_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        # ===== LONG ORDER FILLED START =====
        self.log("INFO", f"ğŸ’° [LONG FILLED] === START PROCESSING FILLED ORDER {event.code} ===")
        self.log("INFO", f"ğŸ’° [LONG FILLED] Portfolio BEFORE UNFREEZE: cash={self.cash:.2f}, frozen={self.frozen:.2f}")
        self.log(
            "INFO",
            f"ğŸ’° [LONG FILLED] Event details: code={event.code}, transaction_volume={event.transaction_volume}, transaction_price={event.transaction_price:.2f}",
        )
        self.log(
            "INFO",
            f"ğŸ’° [LONG FILLED] Financial details: frozen={event.frozen:.2f}, remain={event.remain:.2f}, fee={event.fee:.2f}",
        )

        if self.frozen < event.frozen:
            self.log(
                "CRITICAL", f"Over flow, can not unfreeze {event.frozen} from {self.frozen}. {self.business_timestamp}"
            )
            self.log("ERROR", f"ğŸ’° [LONG FILLED] === FAILED PROCESSING {event.code} (OVERFLOW) ===")
            return
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            self.log("ERROR", f"ğŸ’° [LONG FILLED] === FAILED PROCESSING {event.code} (NEGATIVE REMAIN) ===")
            return

        # ğŸš¨ é‡è¦ä¿®å¤ï¼šä½¿ç”¨æ–°çš„deduct_from_frozenæ–¹æ³•æ­£ç¡®å¤„ç†éƒ¨åˆ†æˆäº¤
        transaction_cost = event.frozen - event.remain
        self.log("INFO", f"ğŸ” [LONG FILLED] Transaction cost: ${transaction_cost:.2f} (converted to Position)")
        self.log("INFO", f"ğŸ” [LONG FILLED] Unfreezing remaining unfilled amount: ${event.remain:.2f}")
        self.log(
            "INFO",
            f"ğŸ” [LONG FILLED] Event details: original_frozen={event.frozen:.2f}, remain={event.remain:.2f}, transaction_cost={transaction_cost:.2f}",
        )

        # ä½¿ç”¨æ–°çš„å…¬å…±æ–¹æ³•ï¼šæ‰£é™¤æˆäº¤èŠ±è´¹ï¼Œåªå°†å‰©ä½™æœªæˆäº¤éƒ¨åˆ†è§£å†»
        self.deduct_from_frozen(cost=transaction_cost, unfreeze_remain=event.remain)

        self.log(
            "INFO",
            f"ğŸ’° [LONG FILLED] Processed transaction cost {transaction_cost:.2f} and unfroze remain {event.remain:.2f}",
        )
        self.log("INFO", f"ğŸ’° [LONG FILLED] Portfolio AFTER: cash={self.cash:.2f}, frozen={self.frozen:.2f}")

        self.add_fee(event.fee)
        self.log("INFO", f"ğŸ’° [LONG FILLED] Added fee: {event.fee:.2f}, New cash: {self.cash:.2f}")

        p = Position(
            portfolio_id=self.uuid,
            engine_id=self.engine_id,
            run_id=self.run_id,
            code=event.code,
            cost=event.transaction_price,
            volume=event.transaction_volume,
            price=event.transaction_price,
            frozen=0,
            fee=event.fee,
            uuid=uuid.uuid4().hex,
        )
        self.add_position(p)
        self.log(
            "INFO",
            f"ğŸ’° [LONG FILLED] Created position: {event.code}, volume={event.transaction_volume}, cost={event.transaction_price:.2f}",
        )

        position_count = len(self.positions)
        total_position_value = sum(pos.worth for pos in self.positions.values() if hasattr(pos, "worth"))
        self.log(
            "INFO",
            f"ğŸ’° [LONG FILLED] Portfolio SUMMARY: cash={self.cash:.2f}, frozen={self.frozen:.2f}, positions={position_count}, total_position_worth={total_position_value:.2f}",
        )

        self.log("WARN", f"Fill a LONG ORDER DONE. {self.business_timestamp}")
        self.log("INFO", f"ğŸ’° [LONG FILLED] === SUCCESSFULLY PROCESSED FILLED ORDER {event.code} ===")
        # ===== LONG ORDER FILLED END =====

    def deal_short_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        if event.code not in self.positions.keys():
            self.log(
                "CRITICAL", f"Can not handler the short order about no exist {event.code}. {self.business_timestamp}"
            )
            return
        if event.transaction_volume > self.positions[event.code].frozen_volume:
            self.log("CRITICAL", f"Can not handler the short order about over flow. {self.business_timestamp}")
            return
        # ğŸš¨ ä¿®å¤ï¼šä¸åº”è¯¥æ·»åŠ event.remainï¼Œå› ä¸ºè¿™éƒ¨åˆ†èµ„é‡‘åº”è¯¥å·²ç»é€šè¿‡unfreezeæ­£ç¡®å¤„ç†äº†
        # self.add_cash(event.remain)  # å·²æ³¨é‡Šæ‰ï¼Œè¿™æ˜¯å¯¼è‡´èµ„é‡‘é‡å¤è®¡ç®—çš„é”™è¯¯
        self.log(
            "INFO",
            f"ğŸ’° [SHORT FILLED] Fixed: NOT adding remain cash {event.remain:.2f} (already handled by unfreeze). {self.business_timestamp}",
        )
        self.add_fee(event.fee)
        self.positions[event.code].deal(DIRECTION_TYPES.SHORT, event.transaction_price, event.transaction_volume)
        self.clean_positions()
        self.log("WARN", f"Fill a SHORT ORDER DONE. {self.business_timestamp}")

    def __repr__(self) -> str:
        """å®‰å…¨çš„__repr__å®ç°ï¼Œé¿å…å¾ªç¯é€’å½’å¯¼è‡´çš„æ€§èƒ½é—®é¢˜"""
        try:
            # åŸºæœ¬ä¿¡æ¯ï¼Œé¿å…è®¿é—®å¯èƒ½å¼•èµ·é€’å½’çš„å±æ€§
            cash = float(self.cash) if hasattr(self, "cash") else 0.0
            frozen = float(self.frozen) if hasattr(self, "frozen") else 0.0
            worth = float(self.worth) if hasattr(self, "worth") else 0.0
            position_count = len(self.positions) if hasattr(self, "positions") else 0
            strategy_count = len(self._strategies) if hasattr(self, "_strategies") else 0

            return (
                f"{PortfolioT1Backtest.__name__}(\n"
                f"  name: {getattr(self, 'name', 'Unknown')}\n"
                f"  uuid: {getattr(self, 'uuid', 'Unknown')[:8]}...\n"
                f"  cash: {cash:,.2f}\n"
                f"  frozen: {frozen:,.2f}\n"
                f"  worth: {worth:,.2f}\n"
                f"  positions: {position_count}\n"
                f"  strategies: {strategy_count}\n"
                f"  time: {getattr(self, 'business_timestamp', 'N/A')}\n"
                f")"
            )
        except Exception:
            # å¼‚å¸¸æ—¶è¿”å›æœ€ç®€ä¿¡æ¯
            return f"{PortfolioT1Backtest.__name__}(name={getattr(self, 'name', 'Unknown')})"
