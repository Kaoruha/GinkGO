"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""

import time
import uuid
import datetime
from rich.console import Console


from typing import List
from ginkgo.trading.bases.portfolio_base import PortfolioBase
from ginkgo.trading.entities.bar import Bar
from ginkgo.trading.entities.position import Position
from ginkgo.trading.entities.signal import Signal
from ginkgo.trading.events import (
    EventOrderAck,
    EventOrderPartiallyFilled,
    EventSignalGeneration,
    EventPriceUpdate,
    EventOrderCancelAck,
)

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, base_repr, to_decimal
from ginkgo.interfaces.notification_interface import INotificationService, NotificationServiceFactory
from ginkgo.data.models import MOrder
from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
)
from ginkgo.data.containers import container


console = Console()


class PortfolioT1Backtest(PortfolioBase):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, notification_service: INotificationService = None, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        # 使用依赖注入的通知服务，如果没有提供则自动创建
        self._notification_service = notification_service or NotificationServiceFactory.create_service()
        self._signals: List[Signal] = []  # 存储Signal对象，用于T+1延迟执行
        self._orders = []

    @property
    def signals(self):
        return self._signals

    @property
    def orders(self):
        return self._orders

    def get_position(self, code: str) -> Position:
        """
        Get Position object from portfolio.
        Args:
            code(str): code
        Returns:
            return POSITION if it exists else return NONE
        """
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def advance_time(self, time: any, *args, **kwargs) -> None:
        """
        时间推进到下一周期
        包含完整的T+1交易制度实现：
        1. 处理T+1结算队列（持仓解冻）
        2. 批量处理延迟信号
        3. 更新投资组合状态
        """
        from ginkgo.libs import datetime_normalize
        new_time = datetime_normalize(time)

        # ===== 步骤1: T+1结算处理 =====
        # 处理所有持仓的结算队列，将到期的冻结持仓转为可用
        settled_positions = 0
        for code, position in self.positions.items():
            initial_settlement_frozen = position.settlement_frozen_volume
            if initial_settlement_frozen > 0:
                position.process_settlement_queue(new_time)
                if position.settlement_frozen_volume < initial_settlement_frozen:
                    settled_positions += 1
                    self.log(
                        "INFO",
                        f"Position {code}: {initial_settlement_frozen - position.settlement_frozen_volume} shares settled, "
                        f"available: {position.volume}, settlement_frozen: {position.settlement_frozen_volume}"
                    )

        if settled_positions > 0:
            self.log("INFO", f"Processed settlement for {settled_positions} positions")

        # ===== 步骤2: 时间推进和状态更新 =====
        # Go next TimePhase - 统一使用hook机制
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        super(PortfolioT1Backtest, self).advance_time(time, *args, **kwargs)
        self.update_worth()
        self.update_profit()

        # ===== 步骤3: 批处理模式处理 =====
        if self._batch_processing_enabled and self._batch_processor:
            try:
                pending_orders = self.force_process_pending_batches()
                if pending_orders:
                    self.log("INFO", f"Processed {len(pending_orders)} pending batch orders at day transition")
            except Exception as e:
                self.log("ERROR", f"Failed to process pending batches during day transition: {e}")

        # ===== 步骤4: T+1信号批量处理 =====
        # 推进到新时间后，批量处理上期的延迟信号
        for signal in self.signals:
            e = EventSignalGeneration(signal)
            self.put(e)

        # Reset past signals
        self._signals = []

        # ===== 步骤5: 新时间状态初始化 =====
        print(self)
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())

    def on_signal(self, event: EventSignalGeneration):
        """
        Dealing with the signal coming.
        支持批处理模式和传统T+1模式
        1. get a signal
        2. after sizer and risk manager
        3.1 drop the signal
        3.2 put order to event engine
        """
        def normalize_time_for_comparison(t):
            """标准化时间用于比较，解决时区不匹配问题"""
            if t is None:
                return None
            # 如果有时间信息，转换为UTC时间并去除时区信息，保持datetime对象类型
            if hasattr(t, 'tzinfo') and t.tzinfo is not None:
                utc_tuple = t.utctimetuple()
                # 标准化夏令时字段为0，确保一致性
                return utc_tuple[:8] + (0,)  # tm_isdst=0
            # 已经是naive时间，转换为struct_time以保持一致性
            if isinstance(t, datetime.datetime):
                naive_tuple = t.timetuple()
                # 标准化夏令时字段为0，确保一致性
                return naive_tuple[:8] + (0,)  # tm_isdst=0
            # 如果已经是其他时间表示，直接返回
            return t

        current_time = self.get_time_provider().now()
        self.log("INFO", f"Got a new Signal about {event.code} {event.direction}. {current_time}")
        self.log(
            "DEBUG", f"{self.name} got a {event.direction} signal about {event.code}  --> {event.direction}. {current_time}"
        )
        self.log("WARNING", f"*** on_signal called with event.business_timestamp={event.business_timestamp}, current_time={current_time} ***")
        self.log("WARNING", f"*** Time comparison: {event.business_timestamp} == {current_time} ? {event.business_timestamp == current_time} ***")
        self.log("WARNING", f"*** Types: business_timestamp type={type(event.business_timestamp)}, current_time type={type(current_time)} ***")
        self.log("WARNING", f"*** Timezones: business_timestamp tzinfo={getattr(event.business_timestamp, 'tzinfo', None)}, current_time tzinfo={getattr(current_time, 'tzinfo', None)} ***")

        # Check Feature Message.
        future_check = self.is_event_from_future(event)
        self.log("WARNING", f"*** is_event_from_future returned: {future_check} ***")
        if future_check:
            self.log("WARNING", f"*** Event from future, dropping signal ***")
            return
        # Check Everything.
        all_set_check = self.is_all_set()
        self.log("WARNING", f"*** is_all_set returned: {all_set_check} ***")
        if not all_set_check:
            self.log("WARNING", f"*** Portfolio not fully set, dropping signal ***")
            return

        # 批处理模式处理
        self.log("INFO", f"=== BATCH PROCESSING CHECK ===")
        self.log("INFO", f"batch_processing_enabled: {self._batch_processing_enabled}")
        self.log("INFO", f"batch_processor exists: {self._batch_processor is not None}")
        self.log("INFO", f"==============================")

        if self._batch_processing_enabled and self._batch_processor:
            try:
                # T+1机制：当天信号延迟到明天处理
                # 注意：批处理模式也需要处理时区问题
                business_time_normalized = normalize_time_for_comparison(event.business_timestamp)
                current_time_normalized = normalize_time_for_comparison(current_time)

                # T+1延迟机制：如果信号时间 >= 当前时间，则延迟到下一个时间点处理
                if business_time_normalized >= current_time_normalized:
                    if business_time_normalized > current_time_normalized:
                        self.log(
                            "WARNING",
                            f"Future signal detected in Batch Mode from {event.business_timestamp} (current: {current_time}), delaying to next period.",
                        )
                    else:
                        self.log(
                            "DEBUG",
                            f"T+1 Batch Mode: delaying current day signal {event.code} to next period. {current_time}",
                        )
                    self.signals.append(event.value)
                    return

                # 使用批处理感知的信号处理
                self._batch_aware_on_signal(event)
                return

            except Exception as e:
                self.log("ERROR", f"Batch signal processing failed, falling back to traditional mode: {e}")
                # 继续执行传统处理逻辑

        # 传统T+1处理逻辑
        # T+1, Order will send after 1 day that signal comes.
        # 注意：时间比较需要处理时区问题，将两个时间都转换为UTC或naive时间
        business_time_normalized = normalize_time_for_comparison(event.business_timestamp)
        current_time_normalized = normalize_time_for_comparison(current_time)

        self.log("INFO", f"=== T+1 TIME COMPARISON DEBUG ===")
        self.log("INFO", f"event.business_timestamp: {event.business_timestamp}")
        self.log("INFO", f"current_time from time_provider: {current_time}")
        self.log("INFO", f"normalized business_time: {business_time_normalized}")
        self.log("INFO", f"normalized current_time: {current_time_normalized}")
        self.log("INFO", f"Are they equal after normalization? {business_time_normalized == current_time_normalized}")
        self.log("INFO", f"=====================================")
        self.log("INFO", f"T+1 CHECK: business_time >= current_time? {business_time_normalized >= current_time_normalized}")

        # T+1延迟机制：如果信号时间 >= 当前时间，则延迟到下一个时间点处理
        # 这确保只有过去的信号才会被立即处理，当天和未来的信号都会被延迟
        if business_time_normalized >= current_time_normalized:
            if business_time_normalized > current_time_normalized:
                self.log(
                    "WARNING",
                    f"Future signal detected from {event.business_timestamp} (current: {current_time}), delaying to next period.",
                )
            else:
                self.log(
                    "DEBUG",
                    f"T+1 delaying current day signal from {event.business_timestamp} (current: {current_time}), will process in next period.",
                )
            self.signals.append(event.value)
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(self.get_info(), event.value)
        # 2. Get the order return
        if order is None:
            self.log("INFO", f"No ORDER about {event.code} generated by sizer. {self.business_timestamp}")
            return
        self.log("INFO", f"Generate an ORDER about {order.code} {order.direction} by sizer. {self.business_timestamp}")

        # 3. Transfer the order to risk_managers
        for risk_manager in self.risk_managers:
            order = risk_manager.cal(self.get_info(), order)
            if order is None:
                break

        # 4. Get the adjusted order, if so put eventorder to engine
        if order is None:
            self.log("WARN", f"ORDER about {event.code} prevent by risk manager. {self.business_timestamp}")
            return
        # Prevent Doing Zero Volume Order
        if order.volume == 0:
            self.log("WARN", f"ORDER about {event.code} prevent by zero volume. {self.business_timestamp}")
            return
        order.frozen_money = round(order.frozen_money, 2)
        order.remain = round(order.remain, 2)
        if order.direction == DIRECTION_TYPES.LONG:
            freeze_ok = self.freeze(order.frozen_money)
            if not freeze_ok:
                self.log("INFO", f"Can not afford the ORDER about {event.code}. {self.business_timestamp}")
                return
        elif order.direction == DIRECTION_TYPES.SHORT:
            if order.code not in self.positions.keys():
                self.log("INFO", f"Do not have position about {order.code}. {self.business_timestamp}")
                return
            freeze_ok = self.get_position(order.code).freeze(order.volume)
            if not freeze_ok:
                self.log("INFO", f"Do not have enough position about {order.code}. {self.business_timestamp}")
                return
        event = EventOrderAck(order, broker_order_id=f"BROKER_{order.uuid[:8]}")
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        self.put(event)

    def on_price_received(self, event: EventPriceUpdate):
        # Check Everything.
        code = ""
        try:
            code = event.code
        except Exception as e:
            pass
        self.log("INFO", f"Got new price {code if code != '' else ""}. {self.business_timestamp}")
        if not self.is_all_set():
            return

        # 0 Time check
        if self.is_event_from_future(event):
            return

        # 1. Update position price
        if event.code in self.positions:
            self.positions[event.code].on_price_update(event.close)
            self.update_worth()
            self.update_profit()

        # 2. Transfer price to each strategy
        if len(self.strategies) == 0:
            self.log("CRITICAL", f"There is no strategy in the portfolio. Check your config. {self.business_timestamp}")
            return

        # GLOG.INFO(f"Under {len(self.strategies)} Strategies Calculating... {self.business_timestamp}")
        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signals = []
            try:
                signals = strategy.cal(self.get_info(), event)

                # 防御性处理：确保signals是列表类型
                if signals is None:
                    signals = []
                elif not isinstance(signals, list):
                    # 如果返回的是单个Signal对象，包装成列表
                    if hasattr(signals, "code"):  # 简单检查是否是Signal对象
                        signals = [signals]
                        self.log(
                            "WARN",
                            f"Strategy {strategy.name} returned single Signal instead of List[Signal], auto-wrapped",
                        )
                    else:
                        self.log("ERROR", f"Strategy {strategy.name} returned invalid type {type(signals)}, ignoring")
                        signals = []

            except Exception as e:
                self.log("ERROR", f"Strategy {strategy.name} cal() failed: {e}")
                signals = []
            finally:
                pass
            # 处理每个信号
            for signal in signals:
                if signal:
                    # 将信号保存到数据库
                    try:
                        signal_crud = container.cruds.signal()
                        signal_crud.create(
                            portfolio_id=signal.portfolio_id,
                            engine_id=signal.engine_id,
                            timestamp=signal.timestamp,
                            code=signal.code,
                            direction=signal.direction,
                            reason=signal.reason,
                            source=signal.source,
                        )
                        self.log("DEBUG", f"Signal saved to database: {signal.code} {signal.direction}")
                    except Exception as e:
                        self.log("ERROR", f"Failed to save signal to database: {e}")

                    e = EventSignalGeneration(signal)
                    e.set_source(SOURCE_TYPES.STRATEGY)
                    for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    self.put(e)

    def on_order_partially_filled(self, event: EventOrderPartiallyFilled):
        self.log("INFO", f"Got An Order Filled... {self.business_timestamp}")
        # debug breakpoint removed
        if self.is_event_from_future(event):
            return

        if not event.order_status == ORDERSTATUS_TYPES.FILLED:
            self.log(
                "CRITICAL",
                f"On Order Filled only handle the FILLEDORDER, cant handle a {event.order_status} one. Check the Code. {self.business_timestamp}",
            )
            return
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"DEALING with LONG FILLED ORDER. {self.business_timestamp}")
            self.deal_long_filled(event)
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"DEALING with SHORT FILLED ORDER. {self.business_timestamp}")
            self.deal_short_filled(event)
        self.log("INFO", f"Got An Order Filled Done. {self.business_timestamp}")
        self.update_worth()
        self.update_profit()

    def on_order_cancel_ack(self, event: EventOrderCancelAck):
        self.log("INFO", f"Got An Order Cancelled... {self.business_timestamp}")
        # debug breakpoint removed
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        self.log("WARN", f"Dealing with CANCELED ORDER. {self.business_timestamp}")
        if self.is_event_from_future(event):
            return
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"START UNFREEZE LONG. {self.business_timestamp}")
            self.unfreeze(event.frozen)
            self.add_cash(event.frozen)
            self.log("INFO", f"Dealing ORDER about {event.code} CANCELED. add frozen cash {event.frozen} {self.business_timestamp}")
            self.log("WARN", f"DONE UNFREEZE LONG. {self.business_timestamp}")
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"START UNFREEZE SHOTR. {self.business_timestamp}")
            code = event.code
            pos = self.positions[code]
            pos.unfreeze(event.volume)
            self.log("WARN", f"DONE UNFREEZE SHORT. {self.business_timestamp}")
        self.update_worth()
        self.update_profit()

    # ===== 新增：订单生命周期事件处理（ACK/部分成交/拒绝/过期/撤销确认） =====
    def on_order_ack(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERACK]:
                func(RECORDSTAGE_TYPES.ORDERACK, self.get_info())
            self.log("INFO", f"ACK: order={event.order_id[:8]} code={event.code} msg={getattr(event, 'ack_message', '')}")
            # 可选：跟踪订单
            if hasattr(self, "_orders") and event.order not in self._orders:
                self._orders.append(event.order)
        except Exception as e:
            self.log("ERROR", f"on_order_ack failed: {e}")

    def on_order_partially_filled(self, event) -> None:
        try:
            if self.is_event_from_future(event):
                return
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED]:
                func(RECORDSTAGE_TYPES.ORDERPARTIALLYFILLED, self.get_info())

            qty = int(getattr(event, "filled_quantity", 0) or 0)
            price = to_decimal(getattr(event, "fill_price", 0) or 0)
            fee = to_decimal(getattr(event, "commission", 0) or 0)
            if qty <= 0 or price <= 0:
                self.log("WARN", f"Partial fill ignored due to invalid qty/price: {qty}/{price}")
                return

            direction = event.order.direction if hasattr(event, "order") else None
            code = event.code

            # LONG 部分成交：消耗冻结资金（成交额+手续费），增加/建立持仓
            if direction == DIRECTION_TYPES.LONG:
                cost_used = price * qty + fee
                self.unfreeze(cost_used)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    p = Position(
                        portfolio_id=self.uuid,
                        code=code,
                        cost=price,
                        volume=qty,
                        price=price,
                        frozen=0,
                        fee=fee,
                        uuid=uuid.uuid4().hex,
                    )
                    self.add_position(p)
                else:
                    pos.deal(DIRECTION_TYPES.LONG, price, qty)

                self.log("INFO", f"PARTIAL LONG filled {code}: {qty}@{price}, fee={fee}")

            # SHORT 部分成交：入账现金（成交额-手续费），消耗持仓冻结量
            elif direction == DIRECTION_TYPES.SHORT:
                proceeds = price * qty - fee
                self.add_cash(proceeds)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    self.log("ERROR", f"Partial SHORT fill but no position found for {code}")
                else:
                    pos.deal(DIRECTION_TYPES.SHORT, price, qty)
                    self.clean_positions()

                self.log("INFO", f"PARTIAL SHORT filled {code}: {qty}@{price}, fee={fee}")
            else:
                self.log("WARN", f"Partial fill with unknown direction for {code}")

            # 更新组合指标
            self.update_worth()
            self.update_profit()

        except Exception as e:
            self.log("ERROR", f"on_order_partially_filled failed: {e}")

    def on_order_rejected(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERREJECTED]:
                func(RECORDSTAGE_TYPES.ORDERREJECTED, self.get_info())
            self.log("WARN", f"REJECTED: order={event.order_id[:8]} code={event.code} reason={event.reject_reason}")
            # BrokerMatchMaking 会同时发送取消事件以触发资金解冻；此处仅记录
        except Exception as e:
            self.log("ERROR", f"on_order_rejected failed: {e}")

    def on_order_expired(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDEREXPIRED]:
                func(RECORDSTAGE_TYPES.ORDEREXPIRED, self.get_info())
            self.log("WARN", f"EXPIRED: order={event.order_id[:8]} code={event.code} reason={event.expire_reason}")
            # 过期一般伴随取消事件；组合在取消事件中做资金/仓位回滚
        except Exception as e:
            self.log("ERROR", f"on_order_expired failed: {e}")

    def on_order_cancel_ack(self, event) -> None:
        try:
            for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())
            for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELACK]:
                func(RECORDSTAGE_TYPES.ORDERCANCELACK, self.get_info())
            self.log(
                "INFO",
                f"CANCEL-ACK: order={event.order_id[:8]} code={event.code} cancelled_qty={event.cancelled_quantity}"
            )
        except Exception as e:
            self.log("ERROR", f"on_order_cancel_ack failed: {e}")

    def deal_long_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        if self.frozen < event.frozen:
            self.log("CRITICAL", f"Over flow, can not unfreeze {event.frozen} from {self.frozen}. {self.business_timestamp}")
            return
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        self.unfreeze(event.frozen)
        self.add_cash(event.remain)
        self.add_fee(event.fee)
        p = Position(
            portfolio_id=self.uuid,
            code=event.code,
            cost=event.transaction_price,
            volume=event.transaction_volume,
            price=event.transaction_price,
            frozen=0,
            fee=event.fee,
            uuid=uuid.uuid4().hex,
        )
        self.add_position(p)
        self.log("WARN", f"Fill a LONG ORDER DONE. {self.business_timestamp}")

    def deal_short_filled(self, event: EventOrderPartiallyFilled, *args, **kwargs):
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        if event.code not in self.positions.keys():
            self.log("CRITICAL", f"Can not handler the short order about no exist {event.code}. {self.business_timestamp}")
            return
        if event.transaction_volume > self.positions[event.code].frozen_volume:
            self.log("CRITICAL", f"Can not handler the short order about over flow. {self.business_timestamp}")
            return
        self.add_cash(event.remain)
        self.log("INFO", f"Got an short filled order, add remain cash: {event.remain}. {self.business_timestamp}")
        self.add_fee(event.fee)
        self.positions[event.code].deal(DIRECTION_TYPES.SHORT, event.transaction_price, event.transaction_volume)
        self.clean_positions()
        self.log("WARN", f"Fill a SHORT ORDER DONE. {self.business_timestamp}")

    def __repr__(self) -> str:
        return base_repr(self, PortfolioT1Backtest.__name__, 24, 70)
