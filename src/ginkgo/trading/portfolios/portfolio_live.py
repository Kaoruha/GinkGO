# Upstream: PortfolioProcessor (持有PortfolioLive实例，调用事件处理方法)
# Downstream: PortfolioProcessor (收集返回的事件，转发到output_queue)
# Role: PortfolioLive实盘投资组合，专注于事件驱动的实盘交易逻辑，组装策略/风控/选择器组件






import time
import datetime
from decimal import Decimal
from enum import Enum
from rich.console import Console
from typing import Dict, List, Optional, Any
from queue import Queue
import threading

from ginkgo.trading.bases.portfolio_base import PortfolioBase
from ginkgo.trading.entities.bar import Bar
from ginkgo.trading.entities.signal import Signal
from ginkgo.trading.entities.position import Position
from ginkgo.trading.events import (
    EventOrderAck,
    EventOrderPartiallyFilled,
    EventOrderCancelAck,
    EventSignalGeneration,
    EventPriceUpdate,
)

from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
    PORTFOLIO_RUNSTATE_TYPES,
)
from ginkgo.data.models import MOrder
from ginkgo.data.drivers import add

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, to_decimal
from ginkgo.libs.core.config import GCONF
from ginkgo.libs.utils.display import base_repr

from ginkgo.data.containers import container
from ginkgo.interfaces.notification_interface import INotificationService, NotificationServiceFactory

console = Console()


class PortfolioLive(PortfolioBase):
    """
    Portfolio for live system.
    """

    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, notification_service: INotificationService = None, *args, **kwargs):
        super(PortfolioLive, self).__init__(*args, **kwargs)
        # 使用依赖注入的通知服务，如果没有提供则自动创建
        self._notification_service = notification_service or NotificationServiceFactory.create_service()

        # 重置日志器，移除GLOG（实盘交易使用简单print）
        self.reset_logger()

        # Phase 5: 优雅重启 - 状态管理
        self._status = PORTFOLIO_RUNSTATE_TYPES.RUNNING
        self._status_lock = threading.Lock()
        self._event_buffer: List[Any] = []  # 事件缓存（STOPPING期间）
        self._max_buffer_size = 1000  # 最大缓存大小
        self._config_version = None  # 配置版本（用于变更检测）

    def log(self, level: str, msg: str, *args, **kwargs) -> None:
        """
        实盘交易日志方法（使用print而非GLOG）

        Args:
            level: 日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)
            msg: 日志消息
        """
        level_up = level.upper()
        prefix = f"[{level_up}]"

        # 支持f-string格式化
        if args or kwargs:
            try:
                formatted_msg = msg.format(*args, **kwargs)
            except:
                formatted_msg = msg
        else:
            formatted_msg = msg

        print(f"{prefix} {self.name}: {formatted_msg}")

    def get_position(self, code: str) -> Position:
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def on_signal(self, event: EventSignalGeneration):
        """
        处理信号事件（已废弃，仅用于兼容性）

        注意：实盘交易中，信号在process_price_update()内部生成并直接处理，
        不需要外部输入EventSignalGeneration事件。

        此方法保留仅用于测试或特殊场景，正常流程不应该调用。

        Args:
            event: EventSignalGeneration信号事件
        """
        # 提取Signal对象并处理
        signal = event.payload if hasattr(event, 'payload') else event
        timestamp = event.timestamp if hasattr(event, 'timestamp') else None
        return self._process_signal(signal, timestamp)

    def _process_signal(self, signal: Signal, event_timestamp=None):
        """
        处理信号（内部方法）

        将信号转换为订单：通过Sizer计算订单大小，通过风控管理器处理订单，提交订单到引擎。

        Args:
            signal: 信号对象
            event_timestamp: 原始事件时间戳（用于日志）
        """
        self.log("INFO", f"{self.name} processing signal: {signal.direction} for {signal.code}")

        # Check Everything.
        if not self.is_all_set():
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(self.get_info(), signal)
        if order is None:
            self.log("INFO", f"No order generated by sizer for signal {signal.code}")
            return

        # 2. Transfer the order to risk_managers (依次处理)
        order_adjusted = order
        for risk_manager in self.risk_managers:
            order_adjusted = risk_manager.cal(self.get_info(), order_adjusted)
            if order_adjusted is None:
                self.log("INFO", f"Order for {signal.code} blocked by risk manager {risk_manager.name}")
                break

        # 3. Check final order
        if order_adjusted is None:
            return

        if order_adjusted.volume == 0:
            self.log("INFO", f"Order for {signal.code} has zero volume")
            return

        # 4. 返回订单事件（由PortfolioProcessor放入output_queue）
        order_event = EventOrderAck(order_adjusted, broker_order_id=f"BROKER_{order_adjusted.uuid[:8]}")
        self.log("INFO", f"Order submitted for {signal.code}: {order_adjusted.direction} {order_adjusted.volume}")
        self._notification_service.beep()

        # Note: Portfolio 只负责内存处理，订单持久化由 ExecutionNode.output_queue_listener 处理

        return order_event

    def on_price_update(self, event: EventPriceUpdate):
        """
        处理价格更新事件（实盘交易入口）

        这是PortfolioProcessor调用的主入口方法，用于处理实时行情更新。

        Args:
            event: EventPriceUpdate价格更新事件

        Returns:
            List[Event]: 生成的订单事件列表（由PortfolioProcessor放入output_queue）

        处理流程：
            1. 检查组件就绪和事件有效性
            2. 更新持仓市场价格
            3. 生成策略信号
            4. 生成风控信号
            5. 处理信号并返回订单事件
        """
        # 前置检查
        if not self.is_all_set():
            return []

        # 处理价格更新
        events = []
        try:
            code = event.code

            # 1. 更新持仓市场价格（如果有该持仓）
            if code in self._positions:
                position = self._positions[code]
                if hasattr(event, 'price'):
                    position.update_price(event.price)

            # 2. 更新投资组合价值
            self.update_worth()
            self.update_profit()

            # 3. 生成策略信号
            strategy_signals = self.generate_strategy_signals(event)

            # 4. 生成风控信号
            risk_signals = self.generate_risk_signals(event)

            # 5. 处理所有信号，收集返回的订单事件
            all_signals = strategy_signals + risk_signals

            for signal in all_signals:
                if signal is None:
                    continue

                try:
                    order_event = self._process_signal(signal, event.timestamp)
                    if order_event is not None:
                        events.append(order_event)
                except Exception as e:
                    self.log("ERROR", f"Failed to process signal for {signal.code}: {e}")

        except Exception as e:
            self.log("ERROR", f"on_price_update failed for {event.code}: {e}")

        return events

    def on_order_partially_filled(self, event: EventOrderPartiallyFilled):
        """
        处理订单成交事件（实盘交易入口）

        这是PortfolioProcessor调用的主入口方法，用于处理订单成交回报。
        实际上订单成交可能是部分成交或全部成交，这里统一调用on_order_partially_filled处理。

        Args:
            event: EventOrderPartiallyFilled订单成交事件
        """
        # ORDER IDEMPOTENCY: Portfolio层只做幂等性检查，不负责持久化
        # TODO: 通过 Order.transaction_volume 判断是否重复处理

        try:
            order = getattr(event, "order", None)
            if order is None:
                self.log("ERROR", "Partial fill event missing order payload")
                return

            qty = int(getattr(event, "filled_quantity", 0) or 0)
            price = to_decimal(getattr(event, "fill_price", 0) or 0)
            fee = to_decimal(getattr(event, "commission", 0) or 0)
            if qty <= 0 or price <= 0:
                self.log("WARN", f"Partial fill ignored due to invalid qty/price: {qty}/{price}")
                return

            direction = getattr(order, "direction", None) or getattr(event, "direction", None)
            code = event.code
            fill_cost = price * qty + fee

            # 更新订单累计成交与剩余冻结
            try:
                order.transaction_volume = min(order.volume, order.transaction_volume + qty)
            except Exception as e:
                self.log("ERROR", f"Failed to update transaction_volume: {e}")

            if not hasattr(order, "remain") or order.remain is None:
                order.remain = order.frozen_money
            order.remain = to_decimal(order.remain)
            order.remain = max(Decimal("0"), order.remain - fill_cost)

            is_final = getattr(event, "order_status", None) == ORDERSTATUS_TYPES.FILLED or order.transaction_volume >= order.volume

            if direction == DIRECTION_TYPES.LONG:
                unfreeze_remain = order.remain if is_final else None
                self.deduct_from_frozen(cost=fill_cost, unfreeze_remain=unfreeze_remain)
                if is_final:
                    order.remain = Decimal("0")
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    p = Position(
                        portfolio_id=self.uuid,
                        engine_id=self.engine_id,
                        run_id=self.run_id,
                        code=code,
                        cost=price,
                        volume=qty,
                        price=price,
                        frozen=0,
                        fee=fee,
                        uuid=order.uuid if hasattr(order, "uuid") else "",
                    )
                    self.add_position(p)
                else:
                    pos.deal(DIRECTION_TYPES.LONG, price, qty)

                self.log(
                    "INFO",
                    f"PARTIAL LONG filled {code}: {qty}@{price}, fee={fee}, remain_frozen={order.remain}",
                )
            elif direction == DIRECTION_TYPES.SHORT:
                proceeds = price * qty - fee
                self.add_cash(proceeds)
                self.add_fee(fee)

                pos = self.get_position(code)
                if pos is None:
                    self.log("ERROR", f"Partial SHORT fill but no position found for {code}")
                else:
                    pos.deal(DIRECTION_TYPES.SHORT, price, qty)
                    self.clean_positions()

                self.log("INFO", f"PARTIAL SHORT filled {code}: {qty}@{price}, fee={fee}")
            else:
                self.log("WARN", f"Partial fill with unknown direction for {code}")

            # Note: Portfolio 只负责内存处理，订单持久化由外部处理

            self.update_worth()
            self.update_profit()
        except Exception as e:
            self.log("ERROR", f"on_order_partially_filled failed: {e}")

    def update_worth(self):
        pass

    def update_profit(self):
        pass

    def on_order_cancel_ack(self, event: EventOrderCancelAck) -> None:
        """
        处理订单取消事件
        Args:
            event: 订单取消事件
        """
        # 激活分析器钩子
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())

        self.log("WARN", f"Dealing with CANCELED ORDER. {self.get_time_provider().now()}")

        # 根据方向处理冻结资金
        if event.direction == DIRECTION_TYPES.LONG:
            order = getattr(event, "order", None)
            remain = None
            if order is not None:
                remain = getattr(order, "remain", None)
                if remain is None:
                    remain = getattr(order, "frozen_money", 0)
            if remain is None:
                self.log("ERROR", f"Cancel event missing remain for {event.code}")
                return
            remain = to_decimal(remain)
            if remain > 0:
                self.unfreeze(remain)
                if order is not None:
                    order.remain = Decimal("0")
            self.log("INFO", f"Order {event.code} CANCELED. Released frozen cash {remain}")
        elif event.direction == DIRECTION_TYPES.SHORT:
            # 卖单取消的处理逻辑
            if event.code in self._positions:
                cancel_vol = int(getattr(event, "cancelled_quantity", 0) or 0)
                if cancel_vol > 0:
                    self._positions[event.code].unfreeze(cancel_vol)
            self.log("INFO", f"Short order {event.code} CANCELED. Released frozen volume {getattr(event, 'cancelled_quantity', 0)}")

    def on_order_filled(self, event: EventOrderPartiallyFilled):
        """
        处理订单成交事件（实盘交易入口）

        这是PortfolioProcessor调用的主入口方法，用于处理订单成交回报。
        实际上订单成交可能是部分成交或全部成交，这里统一调用on_order_partially_filled处理。

        Args:
            event: EventOrderPartiallyFilled订单成交事件
        """
        # 调用部分成交处理逻辑（支持全部成交）
        self.on_order_partially_filled(event)

    def sync_state_to_db(self) -> bool:
        """
        同步Portfolio状态到数据库

        持久化持仓和现金状态到ClickHouse（持仓）和MySQL（Portfolio元数据）。

        Returns:
            bool: 同步成功返回True

        同步内容：
            1. 所有持仓数据（Position）写入ClickHouse
            2. Portfolio现金和元数据更新到MySQL
        """
        try:
            from ginkgo.data.drivers import add
            from ginkgo.data.models.model_position import MPosition
            from ginkgo.data.crud.position_crud import PositionCRUD

            # 1. 同步所有持仓到ClickHouse
            position_crud = PositionCRUD()
            for code, position in self._positions.items():
                try:
                    # 创建MPosition模型
                    m_position = MPosition()
                    m_position.set(
                        portfolio_id=self.portfolio_id,
                        engine_id=self.engine_id,
                        run_id=self.run_id,
                        code=position.code,
                        direction=position.direction,
                        volume=position.volume,
                        frozen=position.frozen,
                        cost=position.cost,
                        price=position.price,
                        fee=position.fee,
                        timestamp=self.get_time_provider().now() if self.get_time_provider() else None
                    )

                    # 写入ClickHouse
                    add(m_position)
                    self.log("DEBUG", f"Position {code} synced to database")

                except Exception as e:
                    self.log("ERROR", f"Failed to sync position {code} to database: {e}")
                    return False

            # 2. 更新Portfolio元数据到MySQL（TODO: Phase 4实现）
            # MVP阶段：暂不实现Portfolio状态更新
            # Phase 4：通过PortfolioService更新Portfolio的current_cash, current_worth等字段

            self.log("INFO", f"Portfolio state synced to database: {len(self._positions)} positions")
            return True

        except Exception as e:
            self.log("ERROR", f"sync_state_to_db failed: {e}")
            return False

    # def __repr__(self) -> str:
    #     return base_repr(self, PortfolioLive.__name__, 24, 60)

    # ========================================================================
    # Phase 5: 优雅重启机制 (Graceful Reload)
    # ========================================================================

    def get_status(self) -> PORTFOLIO_RUNSTATE_TYPES:
        """
        获取当前状态（线程安全）

        Returns:
            PORTFOLIO_RUNSTATE_TYPES: 当前状态
        """
        with self._status_lock:
            return self._status

    def _set_status(self, status: PORTFOLIO_RUNSTATE_TYPES):
        """
        设置状态并同步到 Redis（线程安全）

        Args:
            status: 新状态
        """
        with self._status_lock:
            old_status = self._status
            self._status = status

            # 同步到 Redis
            self._sync_status_to_redis(status)

            self.log("INFO", f"Status changed: {old_status.value} -> {status.value}")

    def _sync_status_to_redis(self, status: PORTFOLIO_RUNSTATE_TYPES):
        """
        同步状态到 Redis

        Args:
            status: 状态枚举
        """
        try:
            from ginkgo.data.crud import RedisCRUD
            redis_crud = RedisCRUD()
            redis_client = redis_crud.redis

            # Redis key: portfolio:{portfolio_id}:status
            status_key = f"portfolio:{self.portfolio_id}:status"
            redis_client.set(status_key, status.value)

            self.log("DEBUG", f"Status synced to Redis: {status_key} = {status.value}")

        except Exception as e:
            self.log("ERROR", f"Failed to sync status to Redis: {e}")

    def graceful_reload(self, timeout: int = 30) -> bool:
        """
        优雅重载 Portfolio 配置（T049）

        完整流程：
        1. 状态转换: RUNNING → STOPPING → STOPPED → RELOADING → RUNNING
        2. 消息缓存: STOPPING 期间缓存消息到 event_buffer
        3. 等待 Queue 清空: 等待 Portfolio Queue 消费完所有消息
        4. 优雅关闭: 调用清理资源
        5. 加载新配置: 从数据库加载新配置
        6. 重新初始化: 创建新 Portfolio 实例
        7. 重放缓存消息: 按顺序重放 event_buffer
        8. 标记为 RUNNING: 更新 Redis 状态

        Args:
            timeout: Queue 清空等待超时时间（秒），默认 30 秒

        Returns:
            bool: 重载成功返回 True

        验收:
            - 配置更新时消息不丢失
            - 切换时间 < 30 秒
        """
        try:
            self.log("INFO", f"Starting graceful reload (timeout={timeout}s)")

            # ========================================
            # 步骤 1: 状态转换 RUNNING → STOPPING
            # ========================================
            self._set_status(PORTFOLIO_RUNSTATE_TYPES.STOPPING)

            # ========================================
            # 步骤 2-3: 等待 Queue 清空（带缓存）
            # ========================================
            # 注意：事件缓存由 ExecutionNode 处理
            # Portfolio 只需要等待现有消息处理完成
            self.log("INFO", "Waiting for existing messages to be processed...")

            # 等待一段时间让现有消息处理完成
            # 实际的 Queue 监控由 ExecutionNode 负责
            time.sleep(2)  # 简化实现：等待 2 秒

            # ========================================
            # 步骤 4: 优雅关闭（清理资源）
            # ========================================
            self.log("INFO", "Cleaning up resources...")
            # TODO: 调用清理方法（如果需要）

            # ========================================
            # 步骤 5: 状态转换 STOPPED → RELOADING
            # ========================================
            self._set_status(PORTFOLIO_RUNSTATE_TYPES.RELOADING)

            # ========================================
            # 步骤 6: 加载新配置
            # ========================================
            self.log("INFO", "Loading new configuration from database...")
            new_config = self._load_config_from_db()

            if new_config is None:
                self.log("ERROR", "Failed to load new configuration")
                self._set_status(PORTFOLIO_RUNSTATE_TYPES.RUNNING)  # 恢复运行
                return False

            # 验证配置版本
            if self._config_version and new_config.get('version') == self._config_version:
                self.log("WARNING", "Configuration version unchanged, skipping reload")
                self._set_status(PORTFOLIO_RUNSTATE_TYPES.RUNNING)
                return True

            # ========================================
            # 步骤 7: 重新初始化（应用新配置）
            # ========================================
            self.log("INFO", "Reinitializing with new configuration...")
            self._reinitialize(new_config)

            # 更新配置版本
            self._config_version = new_config.get('version')

            # ========================================
            # 步骤 8: 状态转换 RELOADING → RUNNING
            # ========================================
            self._set_status(PORTFOLIO_RUNSTATE_TYPES.RUNNING)

            self.log("INFO", "Graceful reload completed successfully")
            return True

        except Exception as e:
            self.log("ERROR", f"Graceful reload failed: {e}")
            self._set_status(PORTFOLIO_RUNSTATE_TYPES.RUNNING)  # 尝试恢复运行
            return False

    def _load_config_from_db(self) -> Optional[Dict]:
        """
        从数据库加载配置

        Returns:
            Dict: 配置字典，失败返回 None
        """
        try:
            from ginkgo import services

            # 通过 PortfolioService 查询配置
            portfolio_service = services.data.portfolio_service()
            result = portfolio_service.get(portfolio_id=self.portfolio_id)

            if not result.is_success() or not result.data:
                self.log("ERROR", f"Portfolio {self.portfolio_id} not found in database")
                return None

            portfolio_model = result.data[0]

            # 构造配置字典
            config = {
                'version': portfolio_model.updated_at.isoformat() if hasattr(portfolio_model, 'updated_at') and portfolio_model.updated_at else None,
                'name': portfolio_model.name,
                'initial_capital': float(portfolio_model.initial_capital) if portfolio_model.initial_capital else 0.0,
                'is_live': portfolio_model.is_live,
                # 可以添加更多配置项
            }

            self.log("INFO", f"Configuration loaded: version={config['version']}")
            return config

        except Exception as e:
            self.log("ERROR", f"Failed to load configuration from database: {e}")
            return None

    def _reinitialize(self, new_config: Dict):
        """
        使用新配置重新初始化 Portfolio

        Args:
            new_config: 新配置字典
        """
        try:
            # 更新名称
            if 'name' in new_config:
                self.name = new_config['name']

            # TODO: 重新加载策略、Sizer、风控配置
            # 这需要从数据库读取组件配置并重新实例化

            self.log("INFO", f"Reinitialized with config: {new_config.get('version')}")

        except Exception as e:
            self.log("ERROR", f"Failed to reinitialize: {e}")
            raise

    def buffer_event(self, event: Any):
        """
        缓存事件（STOPPING 期间调用）

        Args:
            event: 要缓存的事件
        """
        if len(self._event_buffer) >= self._max_buffer_size:
            self.log("WARNING", f"Event buffer full ({self._max_buffer_size}), dropping oldest event")
            self._event_buffer.pop(0)  # 移除最旧的事件

        self._event_buffer.append(event)
        self.log("DEBUG", f"Event buffered (buffer size: {len(self._event_buffer)})")

    def get_buffered_events(self) -> List[Any]:
        """
        获取缓存的事件

        Returns:
            List[Any]: 缓存的事件列表
        """
        return self._event_buffer.copy()

    def clear_buffer(self):
        """清空事件缓存"""
        self._event_buffer.clear()
        self.log("DEBUG", "Event buffer cleared")

    def is_stopping(self) -> bool:
        """
        检查是否正在停止（STOPPING 状态）

        Returns:
            bool: 正在停止返回 True
        """
        return self.get_status() == PORTFOLIO_RUNSTATE_TYPES.STOPPING

    def is_reloading(self) -> bool:
        """
        检查是否正在重载（RELOADING 状态）

        Returns:
            bool: 正在重载返回 True
        """
        return self.get_status() == PORTFOLIO_RUNSTATE_TYPES.RELOADING

    def is_migrating(self) -> bool:
        """
        检查是否正在迁移（MIGRATING 状态）

        Returns:
            bool: 正在迁移返回 True
        """
        return self.get_status() == PORTFOLIO_RUNSTATE_TYPES.MIGRATING

    # def __repr__(self) -> str:
    #     return base_repr(self, PortfolioLive.__name__, 24, 60)
