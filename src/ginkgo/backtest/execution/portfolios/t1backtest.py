"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""

import time
import uuid
from rich.console import Console


from typing import List
from .base_portfolio import BasePortfolio
from ginkgo.backtest.entities.bar import Bar
from ginkgo.backtest.entities.position import Position
from ginkgo.backtest.entities.signal import Signal
from ginkgo.backtest.execution.events import (
    EventOrderSubmitted,
    EventOrderFilled,
    EventSignalGeneration,
    EventPriceUpdate,
    EventOrderCanceled,
)

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, base_repr
from ginkgo.notifier.ginkgo_notifier import GNOTIFIER
from ginkgo.data.models import MOrder
from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
)
from ginkgo.data.containers import container


console = Console()


class PortfolioT1Backtest(BasePortfolio):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        self._signals: List[Signal] = []  # 存储Signal对象，用于T+1延迟执行
        self._orders = []

    @property
    def signals(self):
        return self._signals

    @property
    def orders(self):
        return self._orders

    def get_position(self, code: str) -> Position:
        """
        Get Position object from portfolio.
        Args:
            code(str): code
        Returns:
            return POSITION if it exists else return NONE
        """
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def on_time_goes_by(self, time: any, *args, **kwargs) -> None:
        """
        Go next frame.
        Args:
            time(any): new time
        Return:
            None
        """
        # Go next TimePhase - 统一使用hook机制
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ENDDAY]:
            func(RECORDSTAGE_TYPES.ENDDAY, self.get_info())
        super(PortfolioT1Backtest, self).on_time_goes_by(time, *args, **kwargs)
        self.update_worth()
        self.update_profit()

        # Put old SIGNALs to engine
        # What a new fucking day
        for signal in self.signals:
            e = EventSignalGeneration(signal)
            self.put(e)

        # Reset past signals
        self._signals = []
        print(self)
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.NEWDAY]:
            func(RECORDSTAGE_TYPES.NEWDAY, self.get_info())

    def on_signal(self, event: EventSignalGeneration):
        """
        Dealing with the signal coming.
        1. get a signal
        2. after sizer and risk manager
        3.1 drop the signal
        3.2 put order to event engine
        """
        self.log("INFO", f"Got a new Signal about {event.code} {event.direction}. {self.now}")
        self.log(
            "DEBUG", f"{self.name} got a {event.direction} signal about {event.code}  --> {event.direction}. {self.now}"
        )
        # Check Feature Message.
        if self.is_event_from_future(event):
            return
        # Check Everything.
        if not self.is_all_set():
            return
        # T+1, Order will send after 1 day that signal comes.
        if event.timestamp == self.now:
            self.log(
                "DEBUG",
                f"T+1 Portfolio should not send the order generated from the signal today {event.timestamp}, we will send the order tomorrow. {self.now}",
            )
            self.signals.append(event.value)
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(self.get_info(), event.value)
        # 2. Get the order return
        if order is None:
            self.log("INFO", f"No ORDER about {event.code} generated by sizer. {self.now}")
            return
        self.log("INFO", f"Generate an ORDER about {order.code} {order.direction} by sizer. {self.now}")

        # 3. Transfer the order to risk_managers
        for risk_manager in self.risk_managers:
            order = risk_manager.cal(self.get_info(), order)
            if order is None:
                break

        # 4. Get the adjusted order, if so put eventorder to engine
        if order is None:
            self.log("INFO", f"ORDER about {event.code} prevent by risk manager. {self.now}")
            return
        # Prevent Doing Zero Volume Order
        if order.volume == 0:
            self.log("INFO", f"ORDER about {event.code} prevent by zero volume. {self.now}")
            return
        order.frozen = round(order.frozen, 2)
        order.remain = round(order.remain, 2)
        if order.direction == DIRECTION_TYPES.LONG:
            freeze_ok = self.freeze(order.frozen)
            if not freeze_ok:
                self.log("INFO", f"Can not afford the ORDER about {event.code}. {self.now}")
                return
        elif order.direction == DIRECTION_TYPES.SHORT:
            if order.code not in self.positions.keys():
                self.log("INFO", f"Do not have position about {order.code}. {self.now}")
                return
            freeze_ok = self.get_position(order.code).freeze(order.volume)
            if not freeze_ok:
                self.log("INFO", f"Do not have enough position about {order.code}. {self.now}")
                return
        event = EventOrderSubmitted(order)
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERSEND]:
            func(RECORDSTAGE_TYPES.ORDERSEND, self.get_info())
        self.put(event)

    def on_price_received(self, event: EventPriceUpdate):
        # Check Everything.
        code = ""
        try:
            code = event.code
        except Exception as e:
            pass
        self.log("INFO", f"Got new price {code if code != '' else ""}. {self.now}")
        if not self.is_all_set():
            return

        # 0 Time check
        if self.is_event_from_future(event):
            return

        # 1. Update position price
        if event.code in self.positions:
            self.positions[event.code].on_price_update(event.close)
            self.update_worth()
            self.update_profit()

        # 2. Transfer price to each strategy
        if len(self.strategies) == 0:
            self.log("CRITICAL", f"There is no strategy in the portfolio. Check your config. {self.now}")
            import pdb

            pdb.set_trace()
            return

        # GLOG.INFO(f"Under {len(self.strategies)} Strategies Calculating... {self.now}")
        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signals = []
            try:
                signals = strategy.cal(self.get_info(), event)
                print("Signals:")
                print(signals)
                
                # 防御性处理：确保signals是列表类型
                if signals is None:
                    signals = []
                elif not isinstance(signals, list):
                    # 如果返回的是单个Signal对象，包装成列表
                    if hasattr(signals, 'code'):  # 简单检查是否是Signal对象
                        signals = [signals]
                        self.log("WARN", f"Strategy {strategy.name} returned single Signal instead of List[Signal], auto-wrapped")
                    else:
                        self.log("ERROR", f"Strategy {strategy.name} returned invalid type {type(signals)}, ignoring")
                        signals = []
                        
            except Exception as e:
                self.log("ERROR", f"Strategy {strategy.name} cal() failed: {e}")
                signals = []
            finally:
                pass
            # 处理每个信号
            for signal in signals:
                if signal:
                    # 将信号保存到数据库
                    try:
                        signal_crud = container.cruds.signal()
                        signal_crud.create(
                            portfolio_id=signal.portfolio_id,
                            engine_id=signal.engine_id,
                            timestamp=signal.timestamp,
                            code=signal.code,
                            direction=signal.direction,
                            reason=signal.reason,
                            source=signal.source
                        )
                        self.log("DEBUG", f"Signal saved to database: {signal.code} {signal.direction}")
                    except Exception as e:
                        self.log("ERROR", f"Failed to save signal to database: {e}")
                    
                    e = EventSignalGeneration(signal)
                    e.set_source(SOURCE_TYPES.STRATEGY)
                    for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.SIGNALGENERATION]:
                        func(RECORDSTAGE_TYPES.SIGNALGENERATION, self.get_info())
                    self.put(e)

    def on_order_filled(self, event: EventOrderFilled):
        self.log("INFO", f"Got An Order Filled... {self.now}")
        if self.is_event_from_future(event):
            return

        if not event.order_status == ORDERSTATUS_TYPES.FILLED:
            self.log(
                "CRITICAL",
                f"On Order Filled only handle the FILLEDORDER, cant handle a {event.order_status} one. Check the Code. {self.now}",
            )
            return
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERFILLED]:
            func(RECORDSTAGE_TYPES.ORDERFILLED, self.get_info())
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"DEALING with LONG FILLED ORDER. {self.now}")
            self.deal_long_filled(event)
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"DEALING with SHORT FILLED ORDER. {self.now}")
            self.deal_short_filled(event)
        self.log("INFO", f"Got An Order Filled Done. {self.now}")
        self.update_worth()
        self.update_profit()

    def on_order_canceled(self, event: EventOrderCanceled):
        for func in self._analyzer_activate_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        for func in self._analyzer_record_hook[RECORDSTAGE_TYPES.ORDERCANCELED]:
            func(RECORDSTAGE_TYPES.ORDERCANCELED, self.get_info())
        self.log("WARN", f"Dealing with CANCELED ORDER. {self.now}")
        if self.is_event_from_future(event):
            return
        if event.direction == DIRECTION_TYPES.LONG:
            self.log("WARN", f"START UNFREEZE LONG. {self.now}")
            self.unfreeze(event.frozen)
            self.add_cash(event.frozen)
            self.log("INFO", f"Dealing ORDER about {event.code} CANCELED. add frozen cash {event.frozen} {self.now}")
            self.log("WARN", f"DONE UNFREEZE LONG. {self.now}")
        elif event.direction == DIRECTION_TYPES.SHORT:
            self.log("WARN", f"START UNFREEZE SHOTR. {self.now}")
            code = event.code
            pos = self.positions[code]
            pos.unfreeze(event.volume)
            self.log("WARN", f"DONE UNFREEZE SHORT. {self.now}")
        self.update_worth()
        self.update_profit()

    def deal_long_filled(self, event: EventOrderFilled, *args, **kwargs):
        if self.frozen < event.frozen:
            self.log("CRITICAL", f"Over flow, can not unfreeze {event.frozen} from {self.frozen}. {self.now}")
            return
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            return
        self.unfreeze(event.frozen)
        self.add_cash(event.remain)
        self.add_fee(event.fee)
        p = Position(
            portfolio_id=self.uuid,
            code=event.code,
            cost=event.transaction_price,
            volume=event.transaction_volume,
            price=event.transaction_price,
            frozen=0,
            fee=event.fee,
            uuid=uuid.uuid4().hex,
        )
        self.add_position(p)
        self.log("WARN", f"Fill a LONG ORDER DONE. {self.now}")

    def deal_short_filled(self, event: EventOrderFilled, *args, **kwargs):
        if event.remain < 0:
            self.log("CRITICAL", f"Order can not remain under 0.")
            import pdb

            pdb.set_trace()
            return
        if event.code not in self.positions.keys():
            self.log("CRITICAL", f"Can not handler the short order about no exist {event.code}. {self.now}")
            import pdb

            pdb.set_trace()
            return
        if event.transaction_volume > self.positions[event.code].frozen_volume:
            import pdb

            pdb.set_trace()
            self.log("CRITICAL", f"Can not handler the short order about over flow. {self.now}")
            return
        self.add_cash(event.remain)
        self.log("INFO", f"Got an short filled order, add remain cash: {event.remain}. {self.now}")
        self.add_fee(event.fee)
        self.positions[event.code].deal(DIRECTION_TYPES.SHORT, event.transaction_price, event.transaction_volume)
        self.clean_positions()
        self.log("WARN", f"Fill a SHORT ORDER DONE. {self.now}")

    def __repr__(self) -> str:
        return base_repr(self, PortfolioT1Backtest.__name__, 24, 70)
