"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handles to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ginkgo.backtest.portfolios.base_portfolio import BasePortfolio
    from ginkgo.backtest.events.base_event import EventBase
    from ginkgo.backtest.feeds.base_feed import BaseFeed
    from ginkgo.enums import EVENT_TYPES

import datetime
import threading
from time import sleep
from queue import Queue, Empty


from ginkgo.backtest.engines.base_engine import BaseEngine
from ginkgo.backtest.events import EventNextPhase
from ginkgo.libs.ginkgo_logger import GLOG
from ginkgo.libs.ginkgo_conf import GCONF
from ginkgo.libs import GinkgoSingleLinkedList


class EventEngine(BaseEngine):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(
        self, name: str = "EventEngine", interval: int = 1, *args, **kwargs
    ) -> None:
        super(EventEngine, self).__init__(name, *args, **kwargs)
        self._interval: int = interval
        self._now = None
        self._main_flag = threading.Event()
        self._main_thread: Thread = threading.Thread(
            target=self.main_loop, args=(self._main_flag,)
        )
        self._timer_flag = threading.Event()
        self._timer_thread: Thread = threading.Thread(
            target=self.timer_loop, args=(self._timer_flag,)
        )
        self._handles: dict = {}
        self._general_handles: list = []
        self._timer_handles: list = []
        self._queue: Queue = Queue()
        self._portfolios = GinkgoSingleLinkedList()
        self._datafeeder = None

    @property
    def datafeeder(self):
        return self._datafeeder

    def bind_datafeeder(self, datafeeder: "BaseFeed"):
        self._datafeeder = datafeeder
        if self._datafeeder.engine is None:
            self._datafeeder.bind_engine(self)

    @property
    def now(self) -> datetime.datetime:
        return self._now

    @property
    def portfolios(self) -> GinkgoSingleLinkedList:
        return self._portfolios

    def bind_portfolio(self, portfolio: "BasePortfolio") -> int:
        # ID of this engine is the unique in backtest.
        portfolio.set_backtest_id(self.backtest_id)
        self._portfolios.append(portfolio)
        GLOG.DEBUG(f"{type(self)}:{self.name} bind PORTFOLIO {portfolio.name}.")
        for i in self.portfolios:
            if i.value.engine is None:
                i.value.bind_engine(self)
        l = len(self.portfolios)
        GLOG.DEBUG(f"{type(self)}:{self.name} has {l} PORTFOLIOs.")
        return l

    def main_loop(self, flag) -> None:
        """
        The EventBacktest Main Loop.
        """
        count = 0
        GLOG.reset_logfile("live_main.log")
        while self._active:
            if flag.is_set():
                break
            try:
                # Get a event from events_queue
                event: EventBase = self._queue.get(block=True, timeout=0.5)
                # Pass the event to handle
                self._process(event)
            except Empty:
                GLOG.WARN(f"No Event in Queue. {datetime.datetime.now()} {count}")

            # Break for a while
            sleep(GCONF.HEARTBEAT)
            GLOG.INFO("wait")

    def timer_loop(self, flag) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        GLOG.reset_logfile("live_timer.log")
        while self._active:
            if flag.is_set():
                break
            [handle() for handle in self._timer_handles]
            sleep(self._interval)
            GLOG.WARN("wait")

    def start(self) -> threading.Thread:
        """
        Start the engine
        """
        super(EventEngine, self).start()
        self._main_thread.start()
        self._timer_thread.start()
        GLOG.DEBUG("Engine Start.")
        return self._main_thread

    def stop(self) -> None:
        """
        Pause the Engine
        """
        super(EventEngine, self).stop()
        self._main_flag.set()
        self._timer_flag.set()
        # self._main_thread.join()
        # self._timer_thread.join()
        GLOG.WARN("Engine Stop.")

    def put(self, event: "EventBase") -> None:
        """
        Put event to queue.
        Args:
            event(Event): Event
        Returns:
            None
        """
        self._queue.put(event)
        GLOG.DEBUG(f"{type(self)}:{self.name} put {event.event_type} in queue.")

    def _process(self, event: "EventBase") -> None:
        GLOG.DEBUG(f"Process {event.event_type}")
        if event.event_type in self._handles:
            [handle(event) for handle in self._handles[event.event_type]]
            GLOG.DEBUG(f"{self.name} Deal with {event.event_type}.")
        else:
            GLOG.WARN(f"There is no handler for {event.event_type}")

        if len(self._general_handles) == 0:
            return

        [handle(event) for handle in self._general_handles]

    def register(self, type: "EVENT_TYPES", handle: callable) -> bool:
        """
        Regist the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handle(function): function for dealing with event
        Returns:
            None
        """
        if type in self._handles:
            if handle not in self._handles[type]:
                self._handles[type].append(handle)
                return True
            else:
                GLOG.WARN(f"handle Exists.")
                return False
        else:
            self._handles[type]: list = []
            self._handles[type].append(handle)
            GLOG.INFO(
                f"Register handle {type} : {handle.__name__}"
            )  # handler.__func__ for method object, not support function object.
            return True

    def unregister(self, type: "EVENT_TYPES", handle: callable) -> bool:
        """
        Unregist the event and handler.
        Args:
            type(EVENT_TYPES): type of event.
            handle(function): function for dealing with event
        Returns:
            None
        """
        if type not in self._handles:
            GLOG.WARN(f"Event {type} not exsits. No need to unregister the handle.")
            return False

        if handle not in self._handles[type]:
            GLOG.WARN(f"Event {type} do not own the handle.")
            return False

        self._handles[type].remove(handle)
        GLOG.INFO(f"Unregister handle {type} : {handle}")
        return True

    def register_general(self, handle: callable) -> bool:
        if handle not in self._general_handles:
            self._general_handles.append(handle)
            msg = f"RegisterGeneral : {handle}"
            GLOG.INFO(msg)
            return True
        else:
            msg = f"{handle} already exist."
            GLOG.WARN(msg)
            return False

    def unregister_general(self, handle: callable) -> bool:
        if handle in self._general_handles:
            self._general_handles.remove(handle)
            msg = f"UnregisterGeneral : {handle}"
            GLOG.INFO(msg)
            return True
        else:
            msg = f"{handle} not exsit in Generalhandle"
            GLOG.WARN(msg)
            return False

    def register_timer(self, handle: callable) -> bool:
        if handle not in self._timer_handles:
            self._timer_handles.append(handle)
            GLOG.INFO(f"Register Timer handle: {handle}")
            return True
        else:
            GLOG.WARN(f"Timer handle Exsits.")
            return False

    def unregister_timer(self, handle: callable) -> bool:
        if handle in self._timer_handles:
            self._timer_handles.remove(handle)
            GLOG.INFO(f"Unregister Timer handle: {handle}")
            return True
        else:
            msg = f"Timerhandle {handle} not exists."
            GLOG.WARN(msg)
            return False

    @property
    def handle_count(self) -> int:
        count = 0
        for i in self._handles:
            count += len(self._handles[i])
        return count

    @property
    def general_count(self) -> int:
        return len(self._general_handles)

    @property
    def timer_count(self) -> int:
        return len(self._timer_handles)

    @property
    def todo_count(self) -> int:
        return self._queue.qsize()
