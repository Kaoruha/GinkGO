"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handlers to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""

from typing import TYPE_CHECKING, List

if TYPE_CHECKING:
    from ginkgo.backtest.portfolios.base_portfolio import BasePortfolio
    from ginkgo.backtest.matchmakings import MatchMakingBase
    from ginkgo.backtest.events.base_event import EventBase
    from ginkgo.backtest.feeders.base_feed import BaseFeed
    from ginkgo.enums import EVENT_TYPES

import uuid
import datetime
import time
import threading
from queue import Queue, Empty


from ginkgo.backtest.engines.base_engine import BaseEngine
from ginkgo.backtest.events import EventNextPhase
from ginkgo.libs import GLOG, GCONF


class EventEngine(BaseEngine):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, name: str = "EventEngine", timer_interval: int = 1, *args, **kwargs) -> None:
        super(EventEngine, self).__init__(name, *args, **kwargs)
        self._timer_interval: int = timer_interval
        self._main_flag = threading.Event()
        self._main_thread: Thread = threading.Thread(target=self.main_loop, args=(self._main_flag,))
        self._timer_flag = threading.Event()
        self._timer_thread: Thread = threading.Thread(target=self.timer_loop, args=(self._timer_flag,))
        self._handlers: dict[EVENT_TYPES, callable] = {}
        self._general_handlers: list = []
        self._timer_handlers: list = []
        self._time_hooks: list = []
        self._queue: Queue = Queue()
        self._portfolios: list = []
        self._datafeeder = None
        self._matchmaking = None

    @property
    def datafeeder(self):
        return self._datafeeder

    def bind_datafeeder(self, datafeeder: "BaseFeed"):
        self._datafeeder = datafeeder
        self._datafeeder.bind_engine(self)

    @property
    def matchmaking(self) -> "MatchMakingBase":
        return self._matchmaking

    def bind_matchmaking(self, matchmaking: "MatchMakingBase"):
        self._matchmaking = matchmaking
        self._matchmaking.bind_engine(self)

    @property
    def now(self) -> datetime.datetime:
        return self._now

    @property
    def portfolios(self) -> List:
        return self._portfolios

    def bind_portfolio(self, portfolio: "BasePortfolio") -> None:
        # ID of this engine is the unique in backtest.
        if portfolio in self._portfolios:
            return
        self._portfolios.append(portfolio)
        GLOG.DEBUG(f"{type(self)}:{self.name} bind PORTFOLIO {portfolio.name}.")
        portfolio.bind_engine(self)
        GLOG.DEBUG(f"{type(self)}:{self.name} has {len(self._portfolios)} PORTFOLIOs.")
        if self._datafeeder is not None:
            portfolio.bind_data_feeder(self._datafeeder)

    def main_loop(self, *args, **kwargs) -> None:
        raise NotImplementedError("Mainloop need override.")

    def timer_loop(self, *args, **kwargs) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        while True:
            if self._timer_flag.is_set():
                break
            if self._active:
                [handler() for handler in self._timer_handlers]
            time.sleep(self._timer_interval)
        GLOG.INFO("Timer loop END.")

    def start(self):
        """
        Start the engine
        """
        super(EventEngine, self).start()
        self._active = True
        self._main_thread.start()
        self._timer_thread.start()
        GLOG.INFO("Engine Start.")

    def pause(self) -> None:
        """
        Pause the Engine
        """
        self._active = False
        GLOG.INFO("Engine Pause.")

    def stop(self) -> None:
        """
        Stop the Engine
        """
        super(EventEngine, self).stop()
        self._main_flag.set()
        self._timer_flag.set()
        GLOG.INFO("Engine Stop.")

    def put(self, event: "EventBase") -> None:
        """
        Put event to queue.
        Args:
            event(Event): Event
        Returns:
            None
        """
        self._queue.put(event)
        GLOG.DEBUG(f"{type(self)}:{self.name} got an {event.event_type} in queue.")

    def _process(self, event: "EventBase") -> None:
        GLOG.DEBUG(f"Process {event.event_type}")
        if event.event_type in self._handlers:
            [handler(event) for handler in self._handlers[event.event_type]]
            GLOG.DEBUG(f"{self.name} Deal with {event.event_type}.")
        else:
            GLOG.WARN(f"There is no handlerr for {event.event_type}")

        # General handlerrs
        [handler(event) for handler in self._general_handlers]

    def register(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Regist the event and handlerr.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type in self._handlers:
            if handler not in self._handlers[type]:
                self._handlers[type].append(handler)
                return True
            else:
                GLOG.WARN(f"handler Exists.")
                return False
        else:
            self._handlers[type]: list = []
            self._handlers[type].append(handler)
            GLOG.INFO(
                f"Register handler {type} : {handler.__name__}"
            )  # handlerr.__func__ for method object, not support function object.
            return True

    def unregister(self, type: "EVENT_TYPES", handler: callable) -> bool:
        """
        Unregist the event and handlerr.
        Args:
            type(EVENT_TYPES): type of event.
            handler(function): function for dealing with event
        Returns:
            None
        """
        if type not in self._handlers:
            GLOG.WARN(f"Event {type} not exsits. No need to unregister the handler.")
            return False

        if handler not in self._handlers[type]:
            GLOG.WARN(f"Event {type} do not own the handler.")
            return False

        self._handlers[type].remove(handler)
        GLOG.DEBUG(f"Unregister handler {type} : {handler}")
        return True

    def register_general(self, handler: callable) -> bool:
        if handler not in self._general_handlers:
            self._general_handlers.append(handler)
            msg = f"RegisterGeneral : {handler}"
            GLOG.DEBUG(msg)
            return True
        else:
            msg = f"{handler} already exist."
            GLOG.WARN(msg)
            return False

    def unregister_general(self, handler: callable) -> bool:
        if handler in self._general_handlers:
            self._general_handlers.remove(handler)
            msg = f"UnregisterGeneral : {handler}"
            GLOG.DEBUG(msg)
            return True
        else:
            msg = f"{handler} not exsit in Generalhandler"
            GLOG.WARN(msg)
            return False

    def register_timer(self, handler: callable) -> bool:
        if handler not in self._timer_handlers:
            self._timer_handlers.append(handler)
            GLOG.DEBUG(f"Register Timer handler: {handler}")
            return True
        else:
            GLOG.WARN(f"Timer handler Exsits.")
            return False

    def unregister_timer(self, handler: callable) -> bool:
        if handler in self._timer_handlers:
            self._timer_handlers.remove(handler)
            GLOG.DEBUG(f"Unregister Timer handler: {handler}")
            return True
        else:
            msg = f"Timerhandler {handler} not exists."
            GLOG.WARN(msg)
            return False

    @property
    def handler_count(self) -> int:
        count = 0
        for i in self._handlers:
            count += len(self._handlers[i])
        return count

    @property
    def general_count(self) -> int:
        return len(self._general_handlers)

    @property
    def timer_count(self) -> int:
        return len(self._timer_handlers)

    @property
    def todo_count(self) -> int:
        return self._queue.qsize()

    def register_time_hook(self, hook_func: callable, *args, **kwargs) -> None:
        self._time_hooks.append(hook_func)
