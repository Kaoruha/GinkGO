"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""

import time
import uuid
from rich.console import Console


from ginkgo.backtest.portfolios.base_portfolio import BasePortfolio
from ginkgo.backtest.bar import Bar
from ginkgo.backtest.position import Position
from ginkgo.backtest.signal import Signal
from ginkgo.backtest.events import (
    EventOrderSubmitted,
    EventOrderFilled,
    EventSignalGeneration,
    EventPriceUpdate,
    EventOrderCanceled,
)

from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize, GLOG, base_repr
from ginkgo.notifier.ginkgo_notifier import GNOTIFIER
from ginkgo.data.models import MOrder
from ginkgo.enums import (
    DIRECTION_TYPES,
    SOURCE_TYPES,
    ORDERSTATUS_TYPES,
    RECORDSTAGE_TYPES,
)


console = Console()


class PortfolioT1Backtest(BasePortfolio):
    # The class with this __abstract__  will rebuild the class from bytes.
    # If not run time function will pass the class.
    __abstract__ = False

    def __init__(self, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        self._signals = []
        self._orders = []

    @property
    def signals(self):
        return self._signals

    @property
    def orders(self):
        return self._orders

    def get_position(self, code: str) -> Position:
        """
        Get Position object from portfolio.
        Args:
            code(str): code
        Returns:
            return POSITION if it exsist else return NONE
        """
        if code in self.positions.keys():
            return self.positions[code]
        return None

    def on_time_goes_by(self, time: any, *args, **kwargs) -> None:
        """
        Go next frame.
        Args:
            time(any): new time
        Return:
            None
        """
        # Go next TimePhase
        super(PortfolioT1Backtest, self).on_time_goes_by(time, *args, **kwargs)
        self.update_worth()
        self.update_profit()

        # Put old SIGNALs to engine
        # What a new fucking day
        for signal in self.signals:
            e = EventSignalGeneration(signal)
            self.put(e)

        # Reset past signals
        self._signals = []
        print(self)

    def on_signal(self, event: EventSignalGeneration):
        """
        Dealing with the signal coming.
        1. get a signal
        2. after sizer and risk manager
        3.1 drop the signal
        3.2 put order to event engine
        """
        GLOG.CRITICAL(f"Got a new Signal. {self.now}")
        GLOG.DEBUG(f"{self.name} got a {event.direction} signal about {event.code}  --> {event.direction}. {self.now}")
        # Check Feature Message.
        if self.is_event_from_future(event):
            return
        # Check Everything.
        if not self.is_all_set():
            return
        # T+1, Order will send after 1 day that signal comes.
        if event.timestamp == self.now:
            GLOG.DEBUG(
                f"T+1 Portfolio should not send the order generated from the signal today {event.timestamp}, we will send the order tomorrow. {self.now}"
            )
            self.signals.append(event)
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(self.get_info(), event)
        # 2. Get the order return
        if order is None:
            GLOG.INFO(f"No ORDER about {event.code} generated by sizer. {self.now}")
            return
        GLOG.INFO(f"Generate an ORDER by sizer. {self.now}")

        # 3. Transfer the order to risk_manager
        if self.risk_manager:
            order = self.risk_manager.cal(self.get_info(), order)

        # 4. Get the adjusted order, if so put eventorder to engine
        if order is None:
            GLOG.INFO(f"ORDER about {event.code} prevent by risk manager. {self.now}")
            return
        # Prevent Doing Zero Volume Order
        if order.volume == 0:
            GLOG.INFO(f"ORDER about {event.code} prevent by zero volume. {self.now}")
            return
        order.frozen = round(order.frozen, 2)
        order.remain = round(order.remain, 2)
        if order.direction == DIRECTION_TYPES.LONG:
            freeze_ok = self.freeze(order.frozen)
            if not freeze_ok:
                GLOG.INFO(f"Can not afford the ORDER about {event.code}. {self.now}")
                return
        elif order.direction == DIRECTION_TYPES.SHORT:
            if order.code not in self.positions.keys():
                GLOG.INFO(f"Do not have position about {order.code}. {self.now}")
                return
            freeze_ok = self.get_position(order.code).freeze(order.volume)
            if not freeze_ok:
                GLOG.INFO(f"Do not have enough position about {order.code}. {self.now}")
                return
        event = EventOrderSubmitted(order)
        self.put(event)

    def on_price_received(self, event: EventPriceUpdate):
        # Check Everything.
        GLOG.INFO(f"Got new price. {self.now}")
        if not self.is_all_set():
            return

        # 0 Time check
        if self.is_event_from_future(event):
            return

        # 1. Update position price
        if event.code in self.positions:
            self.positions[event.code].on_price_update(event.close)
            self.update_worth()
            self.update_profit()

        # 2. Transfer price to each strategy
        if len(self.strategies) == 0:
            GLOG.CRITICAL(f"There is no strategy in the portfolio. Check your config. {self.now}")
            import pdb

            pdb.set_trace()
            return

        # GLOG.INFO(f"Under {len(self.strategies)} Strategies Calculating... {self.now}")
        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signal = None
            try:
                signal = strategy.cal(self.get_info(), event)
                print("Signal:")
                print(signal)
            except Exception as e:
                import pdb

                pdb.set_trace()
                print(e)
            finally:
                pass
            if signal:
                e = EventSignalGeneration(signal)
                e.set_source(SOURCE_TYPES.STRATEGY)
                self.put(e)

    def on_order_filled(self, event: EventOrderFilled):
        GLOG.INFO(f"Got An Order Filled... {self.now}")
        if self.is_event_from_future(event):
            return

        if not event.order_status == ORDERSTATUS_TYPES.FILLED:
            GLOG.CRITICAL(
                f"On Order Filled only handle the FILLEDORDER, cant handle a {event.order_status} one. Check the Code. {self.now}"
            )
            return
        if event.direction == DIRECTION_TYPES.LONG:
            GLOG.WARN(f"DEALING with LONG FILLED ORDER. {self.now}")
            # print(event.value)
            # TODO Check first do it as atom operation
            self.deal_long_filled(event)
        elif event.direction == DIRECTION_TYPES.SHORT:
            GLOG.WARN(f"DEALING with SHORT FILLED ORDER. {self.now}")
            # TODO Check first do it as atom operation
            self.deal_short_filled(event)
        GLOG.INFO(f"Got An Order Filled Done. {self.now}")
        self.update_worth()
        self.update_profit()

    def on_order_canceled(self, event: EventOrderCanceled):
        # TODO
        GLOG.WARN(f"Dealing with CANCELED ORDER. {self.now}")
        if self.is_event_from_future(event):
            return
        if event.direction == DIRECTION_TYPES.LONG:
            GLOG.WARN(f"START UNFREEZE LONG. {self.now}")
            self.unfreeze(event.frozen)
            self.add_cash(event.frozen)
            GLOG.WARN(f"DONE UNFREEZE LONG. {self.now}")
        elif event.direction == DIRECTION_TYPES.SHORT:
            GLOG.WARN(f"START UNFREEZE SHOTR. {self.now}")
            code = event.code
            pos = self.positions[code]
            pos.unfreeze(event.volume)
            GLOG.WARN(f"DONE UNFREEZE SHORT. {self.now}")
        self.update_worth()
        self.update_profit()

    def deal_long_filled(self, event: EventOrderFilled, *args, **kwargs):
        if self.frozen < event.frozen:
            GLOG.CRITICAL(f"Over flow, can not unfreeze {event.frozen} from {self.frozen}. {self.now}")
            return
        if event.remain < 0:
            GLOG.CRITICAL(f"Order can not remain under 0.")
            return
        self.unfreeze(event.frozen)
        self.add_cash(event.remain)
        self.add_fee(event.fee)
        p = Position(
            portfolio_id=self.uuid,
            code=event.code,
            cost=event.transaction_price,
            volume=event.transaction_volume,
            price=event.transaction_price,
            frozen=0,
            fee=event.fee,
            uuid=uuid.uuid4().hex,
        )
        self.add_position(p)
        GLOG.WARN(f"Fill a LONG ORDER DONE. {self.now}")

    def deal_short_filled(self, event: EventOrderFilled, *args, **kwargs):
        if event.remain < 0:
            GLOG.CRITICAL(f"Order can not remain under 0.")
            return
        if event.code not in self.positions.keys():
            GLOG.CRITICAL(f"Can not handler the short order about no exist {event.code}. {self.now}")
            return
        if event.transaction_volume > self.positions[event.code].frozen_volume:
            GLOG.CRITICAL(f"Can not handler the short order about over flow. {self.now}")
            return
        self.add_cash(event.remain)
        self.add_fee(event.fee)
        self.positions[event.code].deal(DIRECTION_TYPES.SHORT, event.transaction_price, event.transaction_volume)
        self.clean_positions()
        GLOG.WARN(f"Fill a SHORT ORDER DONE. {self.now}")

    def __repr__(self) -> str:
        return base_repr(self, PortfolioT1Backtest.__name__, 24, 70)
