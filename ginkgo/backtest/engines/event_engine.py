"""
The EventDrivenBacktest class will provide a way to run an event-driven backtest, which involves listening for events (e.g. price updates, order fills) and executing trades based on the signals generated by the Strategy.

- Support both historic and live.

- Registering event handlers to listen for specific types of events (e.g. price updates, order fills).

- Executing trades based on the signals generated by the Strategy in response to these events.

- Generating reports and metrics related to the performance of the backtesting system (By portfolio).
"""
import datetime
import sys
from time import sleep
from queue import Queue, Empty
from threading import Thread
from ginkgo.backtest.engine.base_engine import BaseEngine
from ginkgo.backtest.event.base_event import EventBase
from ginkgo.enums import EVENT_TYPES
from ginkgo import GLOG, GCONF


class EventEngine(BaseEngine):
    def __init__(self, interval: int = 1, *args, **kwargs) -> None:
        super(EventEngine, self).__init__(*args, **kwargs)
        self._interval: int = interval
        self._main_thread: Thread = Thread(target=self.main_loop)
        self._timer_thread: Thread = Thread(target=self.timer_loop)
        self._timer_list: list = []
        self._handlers: dict = {}
        self._general_handler: list = []
        self._queue: Queue = Queue()

    def main_loop(self) -> None:
        """
        The EventBacktest Main Loop.
        """
        count = 0
        max_count = 10000
        while self._active:
            try:
                # Get a event from events_queue
                event: EventBase = self._queue.get(block=True, timeout=0.5)
                # Pass the event to handler
                self._process(event)
                count = 0
            except Empty:
                print(f"No Event in Queue. {datetime.datetime.now()}")
                count += 1
                # Exit
                if count >= max_count:
                    sys.exit()

            # Break for a while
            sleep(GCONF.HEARTBEAT)

    def timer_loop(self) -> None:
        """
        Timer Task. Something like crontab or systemd timer
        """
        while self._active:
            [handler() for handler in self._timer_list]
            sleep(self._interval)

    def start(self) -> None:
        """
        Start the engine
        """
        super(EventEngine, self).start()
        self._main_thread.start()
        self._timer_thread.start()
        GLOG.CRITICAL("Engine start.")

    def stop(self) -> None:
        """
        Pause the Engine
        """
        super(EventEngine, self).stop()
        self._main_thread.join()
        self._timer_thread.join()

    def put(self, event: EventBase) -> None:
        self._queue.put(Event)

    def _process(self, event: EventBase) -> None:
        if event.event_type in self._handlers:
            [handler(event) for handler in self._handlers[event.event_type]]

        if len(self._general_handler) == 0:
            return
        [handler(event) for handler in self._general_handler]

    def register(self, type: EVENT_TYPES, handler: callable) -> None:
        if type in self._handlers:
            if handler not in self._handlers[type]:
                self._handlers[type].append(handler)
            else:
                GLOG.DEBUG(f"Handler Exists.")
        else:
            self._handlers[type]: list = []
            self._handlers[type].append(handler)
            GLOG.INFO(f"Register Handler {type} : {handler}")

    def unregister(self, type: EVENT_TYPES, handler: callable) -> None:
        if type not in self._handlers:
            msg = f"Event {type} not exsits. No need to unregister the handler."
            GLOG.WARN(msg)
            return

        if handler not in self._handlers[type]:
            msg = f"Event {type} do not own the handler."
            GLOG.logger.warn(msg)
            return

        self._handlers[type].remove(handler)
        GLOG.INFO(f"Unregister Handler {type} : {handler}")

    def register_general(self, handler: callable) -> None:
        if handler not in self._general_handler:
            self._general_handler.append(handler)
            msg = f"RegisterGeneral : {handler}"
            GLOG.INFO(msg)
        else:
            msg = f"{handler} already exist."
            GLOG.WARN(msg)

    def unregister_general(self, handler: callable) -> None:
        if handler in self._general_handler:
            self._general_handler.remove(handler)
            msg = f"UnregisterGeneral : {handler}"
            GLOG.logger.info(msg)
        else:
            msg = f"{handler} not exsit in GeneralHandler"
            GLOG.logger.warn(msg)

    def register_timer(self, handler: callable) -> None:
        if handler not in self._timer_list:
            self._timer_list.append(handler)
            GLOG.INFO(f"Register Timer Handler: {handler}")
        else:
            GLOG.DEBUG(f"Timer Handler Exsits.")

    def unregister_timer(self, handler: callable) -> None:
        if handler in self._timer_list:
            self._timer_list.remove(handler)
            GLOG.INFO(f"Unregister Timer Handler: {handler}")
        else:
            msg = f"TimerHandler {handler} not exists."
            GLOG.WARN(msg)
