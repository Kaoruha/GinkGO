"""
The `Portfolio` class is responsible for managing the positions and capital for the system.(Backtest and Live)

- Initializing the portfolio with an initial capital amount and a set of securities to track.

- Keeping track of the current positions and cash balance for the portfolio.

- Executing trades based on signals generated by the Strategy.

- Generating reports and metrics related to the performance of the portfolio. The reports also contain charts.
"""
from ginkgo.backtest.portfolios.base_portfolio import BasePortfolio
from ginkgo.backtest.bar import Bar
from ginkgo import GLOG
from ginkgo.backtest.events import (
    EventOrderSubmitted,
    EventSigalGeneration,
    EventPriceUpdate,
)
from ginkgo.data.ginkgo_data import GDATA
from ginkgo.data.models import MOrder
from ginkgo.libs import GinkgoSingleLinkedList, datetime_normalize
from ginkgo.backtest.signal import Signal


class PortfolioT1Backtest(BasePortfolio):
    def __init__(self, *args, **kwargs):
        super(PortfolioT1Backtest, self).__init__(*args, **kwargs)
        self.signals = GinkgoSingleLinkedList()
        self.orders = GinkgoSingleLinkedList()

    def get_position(self, code: str):
        if code in self.position.keys():
            return self.position[code]
        return None

    def on_time_goes_by(self, time: any, *args, **kwargs):
        # Time goes
        super(PortfolioT1Backtest, self).on_time_goes_by(time, *args, **kwargs)
        # Put old signals to engine
        for signal in self.signals:
            e = EventSigalGeneration(signal)
            self.engine.put(e)
        self.signals = GinkgoSingleLinkedList()

    def on_signal(self, event: EventSigalGeneration):
        # Check Everything.
        if not self.is_all_set():
            return

        if event.timestamp > self.now:
            GLOG.WARN(
                f"Current time is {self.now.strftime('%Y-%m-%d %H:%M:%S')}, The EventSignal generated at {event.timestamp}, Can not handle the future infomation."
            )
            return

        # T+1, Order will send after 1 day that signal comes.
        if event.timestamp == self.now:
            GLOG.INFO(
                f"T+1 Portfolio can not send the order generated from the signal today {event.timestamp}, we will send the order tomorrow"
            )
            self.signals.append(event.value)
            return

        # 1. Transfer signal to sizer
        order = self.sizer.cal(event.value)
        # 2. Get the order return
        if order is None:
            return
        # 3. Transfer the order to risk_manager
        if self.risk_manager is None:
            GLOG.ERROR(
                f"Portfolio RiskManager not set. Can not handle the order. Please set the RiskManager first."
            )
            return
        order_adjsted = self.risk_manager.cal(order)
        # 4. Get the adjusted order, if so put eventorder to engine
        if order_adjsted is None:
            return
        # 5. Create order, stored into db
        freeze_ok = self.freeze(order_adjsted.frozen)
        if freeze_ok:
            mo = MOrder()
            mo.set(
                order_adjsted.code,
                order_adjsted.direction,
                order_adjsted.type,
                order_adjsted.status,
                order_adjsted.volume,
                order_adjsted.limit_price,
                order_adjsted.frozen,
                order_adjsted.transaction_price,
                order_adjsted.remain,
                order_adjsted.fee,
                self.now,
                order_adjsted.uuid,
            )
            GDATA.add(mo)
            e = EventOrderSubmitted(mo.uuid)
            self.orders.append(order_adjsted.uuid)
            # 6. Create Event
            self.engine.put(e)

    def on_price_update(self, event: EventPriceUpdate):
        # Check Everything.
        if not self.is_all_set():
            return
        # 0 Time check
        if event.timestamp > self.now:
            GLOG.WARN(
                f"Current time is {self.now.strftime('%Y-%m-%d %H:%M:%S')}, The EventPriceUpdate generated at {event.timestamp}, Can not handle the future infomation."
            )
            return
        # 1. Update position price
        if event.code in self.position:
            self.position[event.code].on_price_update(event.close)
        # 2. Transfer price to each strategy
        if len(self.strategies) <= 0:
            return

        for strategy in self.strategies:
            # 3. Get signal return, if so put eventsignal to engine
            signal = strategy.value.cal(event.price_info)
            if signal:
                e = EventSigalGeneration(signal)
                self.engine.put(e)
